//===------------------- hbdk_type.h - HBDK type --------------------------===//
//
//                     The HBDK type
//
// This file is subject to the terms and conditions defined in file
// 'LICENSE.txt', which is part of this source code package.
//
//===----------------------------------------------------------------------===//
#ifndef HBDK_TYPE_H_
#define HBDK_TYPE_H_
#pragma once
#include "hbdk_config.h"
#include "hbdk_error.h"

#ifdef __cplusplus
#include <cassert>
#include <cstdint>
#else
#include <assert.h>
#include <stdint.h>
#endif  // __cplusplus

#ifdef __cplusplus
#include <limits>
#include <type_traits>
extern "C" {
#endif

typedef enum {
  ELEMENT_TYPE_UNKNOWN = 0,
  ELEMENT_TYPE_INT8,
  ELEMENT_TYPE_INT16,
  ELEMENT_TYPE_INT32,
  ELEMENT_TYPE_INT64,
  ELEMENT_TYPE_FLOAT32,
  ELEMENT_TYPE_FLOAT64,
  ELEMENT_TYPE_UINT8,
  ELEMENT_TYPE_UINT16,
  ELEMENT_TYPE_UINT32,
  ELEMENT_TYPE_UINT64,
  ELEMENT_TYPE_INT1,
  ELEMENT_TYPE_INT2,
  ELEMENT_TYPE_INT4,
  ELEMENT_TYPE_UINT1,
  ELEMENT_TYPE_UINT2,
  ELEMENT_TYPE_UINT4,
  ELEMENT_TYPE_NUM,
} hbrt_element_type_t;

typedef enum {
  OUTPUT_BY_UNKNOWN = 0,
  OUTPUT_BY_CONV,                                ///< This tensor is generated by conv
  OUTPUT_BY_DETECTION_POST_PROCESS,              ///< This tensor is generated by DetectionPostProcess_X2
  OUTPUT_BY_RCNN_POST_PROCESS,                   ///< This tensor is generated by RCNNPostProcessing_X2
  OUTPUT_BY_DETECTION_POST_PROCESS_STABLE_SORT,  ///< This tensor is generated by DetectionPostProcess_X2 with stable
                                                 ///< sort, which is an cpu operator
  OUTPUT_BY_CHANNEL_ARGMAX,                      ///< This tensor is generated by channel_argmax
  OUTPUT_BY_AUX_DPP_STABLE_SORT,                 ///< This tensor is generated by DetectionPostProcess_X2, which is
                                                 ///< the bpu operator output which helps for dpp stable sort
                                                 ///< This output has no meaning by itself, and has to paired with
                                                 ///< the previous output of OUTPUT_BY_DETECTION_POST_PROCESS
                                                 ///< to get a meaning analysis
  OUTPUT_BY_CHANNEL_ARGMAX_SPLIT,                ///< This tensor is generated by channel_argmax_split
} hbrt_output_operator_type_t;

/**
 * DetectionPostProcess_X2 output and RCNNPostProcessing_X2 int16 output data type.
 * @note DetetionPostProcess_X2's output consists of 16-byte output byte size and
 * N bernoulli_hw_detection_post_process_bbox_type_t, where N is valid box number.
 * The output byte size = N * sizeof(bernoulli_hw_detection_post_process_bbox_type_t)
 * The entire output is organized as:
 * (uint16_t)output_byte_size ******(14 byte padding)
 * (bernoulli_hw_detection_post_process_bbox_with_pad_type_t) box0
 * (bernoulli_hw_detection_post_process_bbox_with_pad_type_t) box1
 * ...
 */
typedef struct {
  int16_t left;
  int16_t top;
  int16_t right;
  int16_t bottom;
  int8_t score;
  uint8_t class_label;
  int16_t padding[3];
} hbrt_bernoulli_hw_detection_post_process_bbox_with_pad_type_t;

typedef hbrt_bernoulli_hw_detection_post_process_bbox_with_pad_type_t
    bernoulli_hw_detection_post_process_bbox_with_pad_type_t
        HBRT_DEPRECATED_NAME(hbrt_bernoulli_hw_detection_post_process_bbox_with_pad_type_t,
                             bernoulli_hw_detection_post_process_bbox_with_pad_type_t, 3.7.1);

typedef struct {
  int16_t left;
  int16_t top;
  int16_t right;
  int16_t bottom;
  int8_t score;
  uint8_t class_label;
} hbrt_bernoulli_hw_detection_post_process_bbox_without_pad_type_t;

typedef hbrt_bernoulli_hw_detection_post_process_bbox_without_pad_type_t
    bernoulli_hw_detection_post_process_bbox_without_pad_type_t
        HBRT_DEPRECATED_NAME(hbrt_bernoulli_hw_detection_post_process_bbox_without_pad_type_t,
                             bernoulli_hw_detection_post_process_bbox_without_pad_type_t, 3.7.1);

typedef struct {
  int32_t n;
  int32_t h;
  int32_t w;
  int32_t c;
} hbrt_dimension_t;

typedef struct {
  hbrt_dimension_t coord;
  hbrt_dimension_t size;
} hbrt_roi_t;

#define HBRT_ROI_INITIALIZER     \
  {                              \
    {0, 0, 0, 0}, { 0, 0, 0, 0 } \
  }

typedef enum {
  HBRT_PAD_ZERO = 0,
  HBRT_PAD_NEAREST,
  HBRT_PAD_CONST,
} hbrt_pad_mode_t;

/**
 * RCNNPostProcessing_X2 float output data type.
 * @note RCNNPostProcessing_X2's float output consists of 24-byte output byte size and
 * N cpu_op_rcnn_post_process_bbox_float_type_t, where N is valid box number.
 * The output byte size = N * sizeof(cpu_op_rcnn_post_process_bbox_float_type_t)
 * The entire output is organized as:
 * (float)output_byte_size ******(20 byte padding)
 * (cpu_op_rcnn_post_process_bbox_float_type_t) box0
 * (cpu_op_rcnn_post_process_bbox_float_type_t) box1
 * ...
 */
typedef struct {
  float left;
  float top;
  float right;
  float bottom;
  float score;
  float class_label;
} hbrt_cpu_op_rcnn_post_process_bbox_float_type_t;

typedef hbrt_cpu_op_rcnn_post_process_bbox_float_type_t cpu_op_rcnn_post_process_bbox_float_type_t HBRT_DEPRECATED_NAME(
    hbrt_cpu_op_rcnn_post_process_bbox_float_type_t, cpu_op_rcnn_post_process_bbox_float_type_t, 3.7.1);

typedef struct {
  const char *name;
  uint32_t bit_size;
} hbrt_element_type_info_t;

typedef hbrt_element_type_info_t element_type_info_t HBRT_DEPRECATED_NAME(hbrt_element_type_info_t, element_type_info_t,
                                                                          3.7.1);
/**
 * Get byte size of given element type. if less than 1 byte, return 0.
 * @param size size of the element type
 * @param t element type enum
 * @return ::hbrtSuccess, ::hbrtErrorIllegalElementType
 */
HBDK_PUBLIC extern hbrt_error_t hbrtGetElementSize(uint32_t *size, hbrt_element_type_t t);

/**
 * Get byte size of given element type
 * @param size size of the element type
 * @param t element type enum
 * @return ::hbrtSuccess, ::hbrtErrorIllegalElementType
 */
HBDK_PUBLIC extern hbrt_error_t hbrtGetElementBitSize(uint32_t *size, hbrt_element_type_t t);

/**
 * Get the name of given element type
 * @param name name of the element type
 * @param t element type num
 * @return ::hbrtSuccess, ::hbrtErrorIllegalElementType
 */
HBDK_PUBLIC extern hbrt_error_t hbrtGetElementTypeName(const char **name, hbrt_element_type_t t);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // HBDK_TYPE_H_
