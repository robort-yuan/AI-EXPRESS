

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>XStream算法SDK编程框架开发指南 &mdash; AI Express用户手册 2.6.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="XProto原型应用开发框架开发指南" href="xproto.html" />
    <link rel="prev" title="快速上手" href="quick_start.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> AI Express用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">快速上手</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XStream算法SDK编程框架开发指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#xstream">XStream设计理念</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">XStream组成</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xstream-framework">XStream-Framework用户手册</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">基本概念与运行机制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">基础数据结构描述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basedata">1.BaseData</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inputparam">2.InputParam</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inputdata">3.InputData</a></li>
<li class="toctree-l4"><a class="reference internal" href="#outputdata">4.OutputData</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#method">Method接口描述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">1.Method基类定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methodfactory">2.MethodFactory定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">3.Method属性</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">XStream-Framework接口描述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#xstream-sdk">1.XStream SDK接口说明</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">2.XStream SDK接口使用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#xstream-workflow">XStream workflow构建</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#workflow">1.workflow骨架结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inputs-outputs">2.inputs/outputs定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node">3.Node定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">4.子workflow定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pythonworkflow">5.基于Python来构建Workflow配置文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">6.workflow配置文件可视化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">XStream开发示例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">1.需求描述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">2.Method开发</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">3.workflow构建</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">4.功能集成</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id24">XStream高阶功能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id25">多路输入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">多路输出</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">Node输出回调</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">workflow线程调度</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">Method运行参数控制</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">内存资源释放</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">超时预警机制</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">workflow嵌套</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">性能统计</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">数据流可视化工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#xstream-tutorials">XStream tutorials</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vision-type">内置数据结构vision_type</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id37">图像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d">2D坐标点与坐标点集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id38">矩形检测框</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id39">单精度浮点数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id40">分割</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id41">3D姿态</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">通用属性类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id43">年龄</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id44">抓拍信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">XStream-Framework使用这些数据结构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id46">内置Method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fasterrcnnmethod">FasterRCNNMethod</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id47">配置文件</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cnnmethod">CNNMethod</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id48">配置文件</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#predictmethod-postprocessmethod">PredictMethod&amp;&amp;PostProcessMethod</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#predictmethod">PredictMethod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#postprocessmethod">PostProcessMethod</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#motmethod">MotMethod</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id49">输入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id50">输出</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id51">配置文件</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#imagetools">图像处理imagetools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id52">功能介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id53">实现方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id54">接口描述</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xproto.html">XProto原型应用开发框架开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="solution.html">场景参考解决方案</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">工具集</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">版权声明</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AI Express用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>XStream算法SDK编程框架开发指南</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/BuildAll/doc/xstream.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xstreamsdk">
<h1>XStream算法SDK编程框架开发指南<a class="headerlink" href="#xstreamsdk" title="永久链接至标题">¶</a></h1>
<p>本文介绍XStream的开发指南，包含XStream-Framework的接口说明、开发流程讲解以及XStream的特性说明。此外会介绍XStream提供的示例代码功能描述。</p>
<p>最后会描述XStream内置的数据结构、Method以及图像处理接口。这些内置模块在沉淀的参考解决方案中大量使用，若想复用那些解决方案，建议对这些内置的模块也熟悉了解，若是基于XStream框架重新开发，则可以完全不依赖这些内置模块。</p>
<div class="section" id="xstream">
<h2>XStream设计理念<a class="headerlink" href="#xstream" title="永久链接至标题">¶</a></h2>
<p>XStream Framework，是一套基于C++实现的算法SDK编程框架。</p>
<ul class="simple">
<li><p><strong>框架通过Workflow来表示一个计算有向图</strong>：框架支持通过Json配置或Python代码两种方式来构建一个有向图。</p></li>
<li><p><strong>Workflow计算拓扑图中每一个计算任务由Method来表示，它为框架核心计算组件</strong>。在智能业务中，Method通常表示一个模型推理(如检测、分类、识别等等)或者一个智能策略（如过滤策略、融合策略、优选策略等等）。在XStream-Framework框架内部，Method会被包装在一个Node节点对象中，XStream-Framework框架由Node对象自动完成Method实例创建、初始化、分配线程资源、任务分发、参数配置等。</p></li>
<li><p><strong>框架提供API接口将Workflow计算拓扑加载到内存，实现Workflow的加载、执行和调度，并对外提供计算API接口</strong>。计算接口参数为待计算的数据帧。通过接口，可以将一个由InputData表示的输入数据帧通过计算拓扑计算完成以后，返回一条或多条<code class="docutils literal notranslate"><span class="pre">OutputData</span></code>输出数据帧。OutputData数据中会记录该帧数据计算结果以及计算状态。</p></li>
</ul>
<p>为了达到简洁，易用，高效的设计目标，XStream-Framework采用了一种<code class="docutils literal notranslate"><span class="pre">数据驱动</span></code>理念来进行设计。相比与另一种<code class="docutils literal notranslate"><span class="pre">面向计算过程</span></code>任务流实现方式，数据驱动设计理念不强调任务流中两个计算节点之间的数据流向，不关心任务流中两节点间数据交换和调度过程，而是通过数据是否可用等数据驱动的方式来对每个计算节点进行独立调度。</p>
<p>下图是两种设计理念的架构图：</p>
<p><img alt="框架" src="../../_images/xstream-scheduling.png" /></p>
<p>其中采用数据驱动的设计理念，可以获得以下收益：</p>
<ul class="simple">
<li><p><strong>简化数据流配置</strong>：基于数据驱动的Workflow拓扑图配置，我们不需要关系拓扑中两个计算节点之间的强链路依赖关系，而只需关心整个Workflow的输入输出数据内容以及每个计算节点数据输入输出内容。这对于一些复杂的数据流场景，可以极大简化workflow设计代价。同时我们可以非常灵活的在拓扑加入新的”专家知识”计算节点来对数据进行加工，持续强化workflow功能。</p></li>
<li><p><strong>高效的内存使用</strong>：数据驱动设计方案关注的是数据字段有效性和可用性，框架可以根据数据依赖关系决定单帧数据内部分字段的有效性，在合适时机将无效数据进行内存回收。相比面向计算过程设计思路，可以极大缩短无效字段数据的生命周期，提高内存的利用效率。</p></li>
<li><p><strong>高效的调度效率</strong>:相比面向计算过程的设计思路,数据驱动在保持计算调度策略简洁的情况下，可以实现极高的调度效率。</p></li>
</ul>
<p>XStream除了支持客户完成自定义Method开发、Workflow配置和算法SDK开发之外，还内置了大量可复用的算法Method和策略Method，支持客户更快完成场景应用逻辑开发。</p>
<p>总之，开发者定义XStream-Framework框架内的数据类型以及Method实现，构建一个workflow，就可以生成一个算法预测SDK(二进制库)。该算法预测SDK的接口在XStream-Framework内已经定义。XStream-Framework框架本身完成workflow的构建、Method的对象创建与运行。</p>
</div>
<div class="section" id="id1">
<h2>XStream组成<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>XStream源码由XStream-Framework、tutorials、vision_type、methods、imagetools组成。各个组件的功能描述如下：</p>
<ul class="simple">
<li><p>XStream-Framework: XStream算法SDK编程框架，定义了最基础的数据类型定义以及Metho的定义；完成Graph的构建以及调度；提供C++接口，支持同步预测/异步预测等功能；支持多路输入、多路输出、子workflow、Profiler、Node输出回调、Method运行参数控制、超时预警等特性；提供数据流可视化工具。开发者基于XStream-Framework库+API接口+基础数据类型定义+Method定义完成SDK开发</p></li>
<li><p>tutorials: XStream-Framework使用的示例，计划覆盖所有的功能特性</p></li>
<li><p>vision_type: 沉淀了视觉相关的数据结构，比如金字塔图像、矩形框、分割、分类属性等。沉淀的solution中大量使用这些数据结构。客户基于XStream-Framework重新开发，可以不依赖vision_type</p></li>
<li><p>methods: 沉淀了XStream-Framework框架下一些Method，比如FasterRCNNMethod、CNNMethod、MotMethod。沉淀的solution中大量使用这些数Method。客户基于XStream-Framework重新开发，可以不依赖这些Method</p></li>
<li><p>imagetools: 沉淀了一套图像处理的C++库，内部封装了OpenCV、libyuv、libturbojpeg等开源库，提供图像解码、图像格式转换、图像缩放、抠图、padding、镜像翻转、中心旋转等功能。客户基于XStream-Framework重新开发，可以不依赖imagetools</p></li>
</ul>
<p>其中XStream-Framework是XStream的核心，客户可以完全基于XStream-Framework，开发Method，构建workflow，完成客户的需求。</p>
</div>
<div class="section" id="xstream-framework">
<h2>XStream-Framework用户手册<a class="headerlink" href="#xstream-framework" title="永久链接至标题">¶</a></h2>
<p>通过本节介绍，你可以熟悉XStream Framework的使用以及内部核心概念。</p>
<p>XStream Framework是一种基于C++实现的基于数据流的编程框架。XStream Framework内部将能⼒组装成Method的形式，每个Method有特定的输入与特定的输出，多个Method通过数据流串联起来，完成一个完整的业务功能集，对外提供服务。XStream Framework的作用是对Method进行抽象、对Method的输入与输出数据结构进行抽象、完成Method的调度等功能。</p>
<div class="section" id="id2">
<h3>基本概念与运行机制<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><strong>workflow</strong>：将一些计算任务级联在一起构建的有向无环图，它定义了一种工作范式。如人脸检测、跟踪、属性（人脸朝向、人脸清晰度等）以及优选策略等计算任务级联在一起定义了一个人脸抓拍范式。</p></li>
<li><p><strong>XStreamSDK</strong>：对外SDK类，提供初始化、设置配置和同步、异步调用等接口。</p></li>
<li><p><strong>Method</strong>：框架核心计算组件，在智能业务中Method通常表示一个模型推理(如检测、分类、识别等等)或者一个智能策略（如过滤策略、融合策略、优选策略等等）。</p></li>
<li><p><strong>Node</strong>：workflow图中一个计算节点，负责method实例创建、分配线程资源、任务分发、参数配置等。每个Node管理了一个或多个method实例。</p></li>
<li><p><strong>Slot</strong>：每个node的输入或者输出端口。</p></li>
<li><p><strong>Data</strong>：Workflow中的每个node之间流转的数据表示，数据表现为一帧一帧，每帧会分配一个唯一单调递增的sequence_id。其中InputData为workflow的输入数据，OutputData为workflow输出数据。</p></li>
<li><p><strong>Param</strong>：Param为一个配置信息，它可以是一个json字符串，也可以是一个普通字符串，支持在框架以及自定义Method实现中进行解析。</p></li>
<li><p><strong>Scheduler</strong>：调度引擎，根据配置workflow的json文件，负责初始化所有Node，构建Node数据依赖关系，当有数据帧输入时，统一调度各个Node，以获取输出结果。</p></li>
<li><p><strong>MethodManager</strong>：用来管理一个Node对象内部的多个Methods，内部会构建一个线程池，根据Method的线程安全属性实例化不同数量的Method实例。</p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>基础数据结构描述<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>基于数据驱动的框架设计，其中最为重要的部分是数据表示，它包括数据帧的表示以及数据帧内每个字段的表示。在数据驱动设计下，数据帧中的每个字段需要有一定的机制来标识数据状态，比如VALID、INVALID、FILTERED、INVISIBLE等，进而可以利用这些状态来实现调度。</p>
<p>在XStream中，通过<code class="docutils literal notranslate"><span class="pre">BaseData</span></code>，<code class="docutils literal notranslate"><span class="pre">BaseDataVector</span></code>,<code class="docutils literal notranslate"><span class="pre">XStreamData</span></code>,<code class="docutils literal notranslate"><span class="pre">InputData</span></code>,<code class="docutils literal notranslate"><span class="pre">OutputData</span></code>，<code class="docutils literal notranslate"><span class="pre">InputParam</span></code>等基础数据类型来表示数据和配置参数。</p>
<div class="section" id="basedata">
<h4>1.BaseData<a class="headerlink" href="#basedata" title="永久链接至标题">¶</a></h4>
<p>Workflow中的每个Node之间流转的数据都是从BaseData继承而来，它定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span>  <span class="n">xstream</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">BaseData</span> <span class="p">{</span>
  <span class="n">BaseData</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseData</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span><span class="c1">// 类型</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span><span class="c1">// 名称</span>
  <span class="kt">int</span> <span class="n">error_code_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 错误码</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error_detail_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span><span class="c1">// 错误信息</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CContext</span><span class="o">&gt;</span> <span class="n">c_data_</span><span class="p">;</span><span class="c1">// C数据结构上下文</span>
  <span class="n">DataState</span> <span class="n">state_</span> <span class="o">=</span> <span class="n">DataState</span><span class="o">::</span><span class="n">VALID</span><span class="p">;</span><span class="c1">// 状态</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">DataState</span> <span class="p">{</span>
  <span class="n">VALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="c1">// 有效</span>
  <span class="n">FILTERED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="c1">// 被过滤掉</span>
  <span class="n">INVISIBLE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="c1">// 不可见</span>
  <span class="n">DISAPPEARED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="c1">// 消失</span>
  <span class="n">INVALID</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// 无效</span>
<span class="p">};</span>

<span class="c1">// 还预定义了数组和从普通数据类型快速转化为XStream数据表示的模板：</span>
<span class="k">struct</span> <span class="nl">BaseDataVector</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseData</span> <span class="p">{</span>
  <span class="n">BaseDataVector</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span> <span class="n">datas_</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 类模板，value可以为任意类型的数据</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dtype</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">XStreamData</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseData</span> <span class="p">{</span>
  <span class="n">Dtype</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">XStreamData</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="n">XStreamData</span><span class="p">(</span><span class="k">const</span> <span class="n">Dtype</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>实例：定义XStream框架BBox数据结构【推荐方法】</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">BBox</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseData</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>实例：将一个已有的BBox数据结构包装为可以输入到XStream中数据表示。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">BBox_</span> <span class="p">{</span>  <span class="c1">// 已有数据结构</span>
  <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">BBox_</span><span class="o">&gt;</span> <span class="n">BBox</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="inputparam">
<h4>2.InputParam<a class="headerlink" href="#inputparam" title="永久链接至标题">¶</a></h4>
<p>InputParam定义了内置执行参数的基类，用户可以继承基类实现自定义参数类.它</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InputParam</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">InputParam</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_name_</span> <span class="o">=</span> <span class="n">unique_name</span><span class="p">;</span>
    <span class="n">is_json_format_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">is_enable_this_method_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">InputParam</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Format</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">is_json_format_</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">is_enable_this_method_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unique_name_</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">InputParam</span><span class="o">&gt;</span> <span class="n">InputParamPtr</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="inputdata">
<h4>3.InputData<a class="headerlink" href="#inputdata" title="永久链接至标题">¶</a></h4>
<p>InputData定义了workflow的输入数据，整体结构表现为一帧一帧的数据流。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 输入数据类型</span>
<span class="k">struct</span> <span class="n">InputData</span> <span class="p">{</span>
  <span class="c1">// 用户输入的数据，比如图片、channel、框等等</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span> <span class="n">datas_</span><span class="p">;</span>
  <span class="c1">// 当前请求自定义的参数</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InputParamPtr</span><span class="o">&gt;</span> <span class="n">params_</span><span class="p">;</span>
  <span class="c1">// 数据源 id 用于多路输入时区分输入源,单一源情况赋值为 0</span>
  <span class="kt">uint32_t</span> <span class="n">source_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 透传的数据，该数据会透传到OutputData::context_ 字段</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="outputdata">
<h4>4.OutputData<a class="headerlink" href="#outputdata" title="永久链接至标题">¶</a></h4>
<p>OutputData定义了workflow的输出数据，整体结构表现为一帧一帧的数据流。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 输出数据类型</span>
<span class="k">struct</span> <span class="n">OutputData</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">error_code_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 错误码</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error_detail_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span><span class="c1">// 错误信息</span>
  <span class="c1">// 当该OutputData为给某个Method的定向回调结果时，该字段用于指示Method名称</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unique_name_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output_type_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span><span class="c1">// 多路输出结果名称</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span> <span class="n">datas_</span><span class="p">;</span><span class="c1">// 输出结果</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span><span class="c1">// 从InputData透传过来的数据</span>
  <span class="kt">int64_t</span> <span class="n">sequence_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 该结果的序列号</span>
  <span class="kt">uint32_t</span> <span class="n">source_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 该结果是属于那个输入源产生的结果</span>
  <span class="kt">uint64_t</span> <span class="n">global_sequence_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">OutputData</span><span class="o">&gt;</span> <span class="n">OutputDataPtr</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">error_code_</span></code>等字段记录了该数据在处理过程中是否成功信息。</p>
</div>
</div>
<div class="section" id="method">
<h3>Method接口描述<a class="headerlink" href="#method" title="永久链接至标题">¶</a></h3>
<p>Method是框架中核心计算组件，在智能业务中Method通常表示一个模型推理(如检测、分类、识别等等)或者一个智能策略（如过滤策略、融合策略、优选策略等等）。但是XStream Framework框架本身，Method是不区分模型推理或智能策略，我们开放接口支持客户定义任意计算逻辑。</p>
<div class="section" id="id4">
<h4>1.Method基类定义<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>下面是Method的接口类：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Method</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Method</span><span class="p">();</span>
  <span class="c1">/// 初始化</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">config_file_path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">Json</span><span class="o">::</span><span class="n">Value</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">/// 获取Method运行参数配置</span>
  <span class="k">virtual</span> <span class="n">InputParamPtr</span> <span class="nf">GetParameter</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 动态改变Method运行参数配置</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">UpdateParameter</span><span class="p">(</span><span class="n">InputParamPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// 获取Method版本号，比如 metric_v0.4.0 或者 MD112 等</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetVersion</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// 获取Method基本信息</span>
  <span class="k">virtual</span> <span class="n">MethodInfo</span> <span class="nf">GetMethodInfo</span><span class="p">();</span>
  <span class="c1">/// 用于告知Method整个SDK的Profiler状态更改</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnProfilerChanged</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 数据处理函数，第一个参数是输入数据（双重vector，外层vector表示batch是多帧的输入</span>
  <span class="c1">// 内层的vector表示单帧的数据列表），</span>
  <span class="c1">// 内层vector对应workflow的&quot;inputs&quot;输入列表</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="n">DoProcess</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InputParamPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// 析构</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Finalize</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Method</span><span class="o">&gt;</span> <span class="n">MethodPtr</span><span class="p">;</span>

<span class="p">}</span>  <span class="c1">// namespace xstream</span>
</pre></div>
</div>
<ul>
<li><p><strong>初始化</strong>：Method初始化支持读取一个配置文件进行初始化或一个配置字符串进行初始化，在Workflow构建时候，会做相应的配置，详细参见<a class="reference external" href="#3.workflow%E6%9E%84%E5%BB%BA">workflow构建</a></p></li>
<li><p><strong>资源回收</strong>：Method作为计算组件，初始化过程中会申请占用一些计算资源和存储资源，在SDK退出时，需要严格对申请资源进行回收，避免资源泄漏。</p></li>
<li><p><strong>参数更新</strong>: 除了初始化设置Method参数，框架也支持通过<code class="docutils literal notranslate"><span class="pre">XStreamSDK::UpdateConfig</span></code>接口在运行时动态调整Method内部的参数。</p></li>
<li><p><strong>MethodInfo</strong>: 定义了Method属性信息，详细参见<a class="reference external" href="#3.Method%E5%B1%9E%E6%80%A7">Method属性</a></p></li>
<li><p><strong>计算接口</strong>：<code class="docutils literal notranslate"><span class="pre">DoProcess</span></code>定义了Method实际计算逻辑。</p>
<ul class="simple">
<li><p>函数输入<code class="docutils literal notranslate"><span class="pre">input</span></code>和函数返回值都是按照Batch方式进行数据帧处理，BatchNum=1时即为单帧数据处理，通过该设计来满足一些需要Batch计算的场景需求。</p></li>
<li><p>输入参数<code class="docutils literal notranslate"><span class="pre">input</span></code>的每个Batch数据类型为<code class="docutils literal notranslate"><span class="pre">std::vector&lt;BaseDataPtr&gt;</span></code>。在数据驱动调度方式中，框架会根据workflow Node定义传递相应字段数据到函数中，而非帧数据的全部字段。</p></li>
<li><p>函数返回值的每个Batch数据类型也为<code class="docutils literal notranslate"><span class="pre">std::vector&lt;BaseDataPtr&gt;</span></code>。框架会根据workflow Node定义字段，将会返回值写回到相应帧中。因此需要保证返回值帧字段个数与配置个数一致。</p></li>
<li><p>输入参数<code class="docutils literal notranslate"><span class="pre">param</span></code>的每个Batch数据类型为<code class="docutils literal notranslate"><span class="pre">InputParamPtr</span></code>，每个InputParamPtr是method单帧处理输入输出的特殊处理配置，详细可参考<a class="reference external" href="#Method%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8E%A7%E5%88%B6">Method运行参数控制</a>。</p></li>
<li><p>参考下面Methode Node定义实例：每个数据帧输入字段数目为1个<code class="docutils literal notranslate"><span class="pre">image</span></code>,输出的字段数目为3个，分别是<code class="docutils literal notranslate"><span class="pre">rgb_face_box,rgb_lmk,rgb_pose</span></code>。</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;FasterRCNNMethod&quot;</span><span class="p">,</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;image&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;rgb_face_box&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rgb_lmk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rgb_pose&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;face_pose_lmk.json&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="methodfactory">
<h4>2.MethodFactory定义<a class="headerlink" href="#methodfactory" title="永久链接至标题">¶</a></h4>
<p>定义MethodFactory以实现Method的实例化，下面是MethodFactory的定义：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="n">method_factory</span> <span class="p">{</span>
    <span class="c1">// 默认全局Method Factory工厂函数的声明</span>
    <span class="c1">// 该符号为一个弱符号,也就是说:如果这个函数没有</span>
    <span class="c1">// 被定义,编译链接仍然成功,但是使用的时候会报错</span>
    <span class="c1">// 这样做的好处是,如果用户不使用Default Method Factory,</span>
    <span class="c1">// 就不需要再定义一个为了防止链接出错的空函数放进代码里</span>
    <span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span>  <span class="c1">// NOLINT</span>
    <span class="n">MethodPtr</span> <span class="n">CreateMethod</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">method_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace xstream</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>CreateMethod</strong>：用户在自定义Method后，需要通过实现CreateMethod完成Method实例创建。MethodFactory的工厂函数会根据不同的method_name名字返回对应的Method的实例，workflow中用到的Method都需要添加到该函数中。</p></li>
</ul>
<p>示例：参考下面Methode Node定义实例，需要实例化FasterRCNN Method和CNNMethod。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
  &quot;method_type&quot;: &quot;FasterRCNNMethod&quot;,
  &quot;inputs&quot;: [
    &quot;image&quot;
  ],
  &quot;outputs&quot;: [
    &quot;rgb_face_box&quot;,
    &quot;rgb_lmk&quot;,
    &quot;rgb_pose&quot;
  ],
  &quot;method_config_file&quot;: &quot;face_pose_lmk.json&quot;
},
{
  &quot;method_type&quot;: &quot;CNNMethod&quot;,
  &quot;unique_name&quot;: &quot;age_gender&quot;,
  &quot;inputs&quot;: [
    &quot;rgb_face_box&quot;,
    &quot;image&quot;
  ],
  &quot;outputs&quot;: [
    &quot;age&quot;,
    &quot;gender&quot;
  ],
  &quot;method_config_file&quot;: &quot;age_gender.json&quot;
}
</pre></div>
</div>
<p>实现具体的CreateMethod：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">method_factory</span> <span class="p">{</span>
<span class="n">MethodPtr</span> <span class="n">CreateMethod</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">method_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="s">&quot;FasterRCNNMethod&quot;</span> <span class="o">==</span> <span class="n">method_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MethodPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">FasterRCNNMethod</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="s">&quot;CNNMethod&quot;</span> <span class="o">==</span> <span class="n">method_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MethodPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">CNNMethod</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MethodPtr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">//  namespace method_factory</span>
<span class="p">}</span>  <span class="c1">//  namespace xstream</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>3.Method属性<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>自定义Method，可以通过实现<code class="docutils literal notranslate"><span class="pre">virtual</span> <span class="pre">MethodInfo</span> <span class="pre">GetMethodInfo();</span></code>函数来对Method的一些属性进行配置。</p>
<p>MethidInfo定义如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">MethodInfo</span> <span class="p">{</span>
  <span class="c1">// 是否线程安全</span>
  <span class="kt">bool</span> <span class="n">is_thread_safe_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// 是否需要做reorder，也就是让每一帧结果的返回顺序同请求顺序。</span>
  <span class="kt">bool</span> <span class="n">is_need_reorder</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// 是否对输入源有前后文依赖 source context dependent</span>
  <span class="kt">bool</span> <span class="n">is_src_ctx_dept</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中is_thread_safe_和is_need_reorder两个属性最为重要：</p>
<ul class="simple">
<li><p>属性is_thread_safe_定义了Method是否为线程安全。在Workflow定义时候，支持配置Node的线程数。如果线程数配置大于1，此时要求Method计算过程的实现，需要满足线程安全的要求。默认值是false，在需要配置Method多实例并发时，需要设置该属性为True。</p></li>
<li><p>属性is_need_reorder定义了是否要求数据按顺逐帧调用Method计算函数。比如一些目标跟踪场景，要求输出数据是有序的。默认是false，表示为不要求有序。</p>
<ul>
<li><p>注意：在is_reorder=true的method，由于有前后帧序依赖，线程数只允许为1。同时is_reorder会一定程度上降低Method执行效率。</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id6">
<h3>XStream-Framework接口描述<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>XStream Framework主要功能是支持用户自定义Method计算任务，为了更直观地让用户熟悉XStream Framework的使用，我们现在来介绍下XStream Framework的接口。</p>
<div class="section" id="xstream-sdk">
<h4>1.XStream SDK接口说明<a class="headerlink" href="#xstream-sdk" title="永久链接至标题">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="cm">/**</span>
<span class="cm"> * 典型使用</span>
<span class="cm"> * xstream::XStreamSDK *flow = xstream::XStreamSDK::CreateSDK();</span>
<span class="cm"> * flow-&gt;SetConfig(&quot;config_file&quot;, config);</span>
<span class="cm"> * flow-&gt;Init();</span>
<span class="cm"> * InputDataPtr inputdata(new InputData());</span>
<span class="cm"> * // ... 构造输入数据</span>
<span class="cm"> * auto out = flow-&gt;SyncPredict(inputdata);</span>
<span class="cm"> * // PrintOut(out);</span>
<span class="cm"> * // ... 处理输出结果</span>
<span class="cm"> * delete flow;</span>
<span class="cm"> */</span>
<span class="c1">// 数据流提供的接口</span>
<span class="k">class</span> <span class="nc">XStreamSDK</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 因为构造出来的实例是XStreamSDK接口的子类</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">XStreamSDK</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// 通过此方法构造SDK实例</span>
  <span class="k">static</span> <span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">CreateSDK</span><span class="p">();</span>

  <span class="c1">//说明：用于设置整个workflow的配置，目前支持的功能有：  </span>
  <span class="c1">//1）key为&quot;config_file&quot;，value设置为workflow的配置路径，它定义整个workflow数据流。   </span>
  <span class="c1">//2）key为&quot;profiler&quot;，value为&quot;on&quot;，表示打开性能统计功能。&quot;off&quot;表示关闭, 默认为关闭。   </span>
  <span class="c1">//3）key为&quot;profiler_file&quot;,value为性能统计输出文件路径，用于设置性能统计文件的路径名称，默认为./profiler.txt   </span>
  <span class="c1">//4）key为&quot;free_framedata&quot;, value为&quot;on&quot;, 表示尽早地释放掉在后面node节点中不再需要使用的Framework Data中的某项数据。   </span>
  <span class="c1">//打开此项配置,可以减少峰值内存使用。&quot;off&quot;表示关闭, 默认为关闭。 </span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">SetConfig</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

  <span class="c1">//用于初始化xstream句柄，必须在调用SetConfig之后执行Init()</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Init</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 用于设置node的参数，最终会通过调用对应的node管理的method实例的UpdateParameter(InputParamPtr ptr)接口，完成参数的更新。</span>
  <span class="c1">// 形参unique_name传入node的名字；形参ptr为该node对应的配置信息</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">UpdateConfig</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">,</span> <span class="n">InputParamPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">//获取某个node的参数，最终会调用对应的node管理的method实例的GetParameter()返回配置信息。</span>
  <span class="k">virtual</span> <span class="n">InputParamPtr</span> <span class="nf">GetConfig</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 获取node对应method的版本信息。</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 同步运行接口，传⼊数据，接口会阻塞住，直到整个workflow处理完成，将workflow的结果通过函数返回值返回为止。</span>
  <span class="c1">// 该接口需要在Init()之后执行才有效。</span>
  <span class="k">virtual</span> <span class="n">OutputDataPtr</span> <span class="nf">SyncPredict</span><span class="p">(</span><span class="n">InputDataPtr</span> <span class="n">input</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 同步多路输出的场景下， 输出接口可以通过output_type_信息判断输出类型。</span>
  <span class="k">virtual</span> <span class="n">OutputDataPtr</span> <span class="nf">SyncPredict2</span><span class="p">(</span><span class="n">InputDataPtr</span> <span class="n">input</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 使用异步运行接口时，设置SetCallback才有效。</span>
  <span class="c1">// 将name设置为默认值，通过该接口可以设置整个workflow处理完成后的回调函数；</span>
  <span class="c1">// 将name设置为某个node的unique名字，通过该接口可以设置该node处理数据完成后的回调函数。</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">SetCallback</span><span class="p">(</span><span class="n">XStreamCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

  <span class="c1">// 异步运行接口，结果通过SetCallback设置的回调函数捕获。AsyncPredict接口调用后立即返回。</span>
  <span class="c1">// 该接口需要在Init()之后执行才有效。</span>
  <span class="k">virtual</span> <span class="kt">int64_t</span> <span class="nf">AsyncPredict</span><span class="p">(</span><span class="n">InputDataPtr</span> <span class="n">input</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">};</span>
</pre></div>
</div>
<p>XStreamSDK核心功能是将一个Workflow配置转化为算法SDK：</p>
<ul class="simple">
<li><p>XStreamSDK实例创建：每个XStreamSDK实例，对应一个具体的workflow。同一个进程，可以创建多个XStreamSDK实例，用于运行不同的workflow。</p></li>
<li><p>XStreamSDk实例配置：其中最重要是<code class="docutils literal notranslate"><span class="pre">config_file</span></code>，它即为Workflow配置。同时也支持通过<code class="docutils literal notranslate"><span class="pre">UpdateConfig</span></code>和<code class="docutils literal notranslate"><span class="pre">GetConfig</span></code>来动态获取和修改Workflow中各个配置。</p></li>
<li><p>XStreamSDk实例初始化：即<code class="docutils literal notranslate"><span class="pre">Init</span></code>过程，它基于<code class="docutils literal notranslate"><span class="pre">config_file</span></code>定义的Workflow配置，完成计算拓扑的构建和初始化。</p></li>
<li><p>XStreamSDk预测接口：针对一个InputData数据进行计算，返回一个OutputData数据。当前支持<strong>同步计算和异步回调</strong>两种模式。</p></li>
</ul>
</div>
<div class="section" id="id7">
<h4>2.XStream SDK接口使用<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p><strong>同步运行模式</strong>：通过<code class="docutils literal notranslate"><span class="pre">SyncPredict</span></code>函数堵塞进行调用。</p>
<p>实例代码如下:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/sync_main.cc</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseData</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataPtr</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataVector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputData</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputDataPtr</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">config</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
<span class="c1">/// Get Method Version</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BBoxFilter_A Method Version : &quot;</span>
          <span class="o">&lt;&lt;</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">GetVersion</span><span class="p">(</span><span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的左上角横坐标</span>
<span class="kt">float</span> <span class="n">y1</span><span class="p">{</span><span class="mi">20</span><span class="p">};</span>  <span class="c1">// BBox(框)的左上角纵坐标</span>
<span class="kt">float</span> <span class="n">x2</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的右上角横坐标</span>
<span class="kt">float</span> <span class="n">y2</span><span class="p">{</span><span class="mi">50</span><span class="p">};</span>  <span class="c1">// BBox(框)的右上角纵坐标</span>
<span class="c1">// 框的面积计算公式:(x2-x2)*(y2-y1)</span>
<span class="c1">// 生成面积为{ 0, 30, 60, 90, 120, 150, 180, 210, 240,</span>
<span class="c1">// 270 } 序列,作为BBoxFilter的输入数据</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)));</span>
  <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
  <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
  <span class="n">ParseOutput</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">delete</span> <span class="n">flow</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>异步运行模式</strong>：通过<code class="docutils literal notranslate"><span class="pre">SetCallback</span></code>设置回调函数，实现<code class="docutils literal notranslate"><span class="pre">AsyncPredict</span></code>非堵塞调用。</p>
<p>实例代码所示:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/async_main.cc</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseData</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataPtr</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataVector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputData</span><span class="p">;</span>
<span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputDataPtr</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Stage1Async</span><span class="o">::</span><span class="n">Callback</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">config</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
<span class="n">Callback</span> <span class="n">callback</span><span class="p">;</span>
<span class="c1">// 整个Workflow回调函数</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
<span class="c1">// BBoxFilter_A回调函数</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">),</span>
    <span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">);</span>
<span class="c1">// BBoxFilter_B回调函数</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">),</span>
    <span class="s">&quot;BBoxFilter_B&quot;</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">x1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的左上角横坐标</span>
<span class="kt">float</span> <span class="n">y1</span><span class="p">{</span><span class="mi">20</span><span class="p">};</span>  <span class="c1">// BBox(框)的左上角纵坐标</span>
<span class="kt">float</span> <span class="n">x2</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的右上角横坐标</span>
<span class="kt">float</span> <span class="n">y2</span><span class="p">{</span><span class="mi">50</span><span class="p">};</span>  <span class="c1">// BBox(框)的右上角纵坐标</span>
<span class="c1">// 框的面积计算公式:(x2-x2)*(y2-y1)</span>
<span class="c1">// 生成面积为{ 0, 30, 60, 90, 120, 150, 180, 210, 240,</span>
<span class="c1">// 270 } 序列,作为BBoxFilter的输入数据</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)));</span>
  <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
  <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
  <span class="c1">// waiting for async function done</span>
  <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="k">delete</span> <span class="n">flow</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="xstream-workflow">
<h3>XStream workflow构建<a class="headerlink" href="#xstream-workflow" title="永久链接至标题">¶</a></h3>
<p>workflow定义了整个计算拓扑结构，XStream SDK支持读取Workflow配置文件来在构建一个算法SDK。文件内容为一个json字符串，它定义了一个完整的workflow拓扑结构。</p>
<div class="section" id="workflow">
<h4>1.workflow骨架结构<a class="headerlink" href="#workflow" title="永久链接至标题">¶</a></h4>
<p>下面是一个workflow配置示例</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;workflow&quot;</span><span class="p">,</span>  
  <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;workflow&quot;</span><span class="p">,</span> 
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box_filter2&quot;</span><span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它的骨干结构如下：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
	&quot;name&quot;: &quot;xxx&quot;,         // workflow名称，需唯一化
	&quot;type&quot;: &quot;workflow&quot;,    // 表示Workflow对象
	&quot;inputs&quot;: [],          // 输入slots名称
	&quot;outputs&quot;: [],         // 输出slots名称
	&quot;workflow&quot;: [          // Workflow内容，包括Node或Workflow对象(子workflow)
	]
}
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>定义了workflow名称，默认可以省略，内部会自定生成一个唯一名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs/outputs</span></code>定义了workflow整个有效输入输出名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workflow</span></code>定义了整个拓扑的结构，它由多个Node或Workflow对象(子workflow)组成。Node之间通过inputs和outputs字段来构建起数据依赖。</p></li>
</ul>
</div>
<div class="section" id="inputs-outputs">
<h4>2.inputs/outputs定义<a class="headerlink" href="#inputs-outputs" title="永久链接至标题">¶</a></h4>
<p>对于XStream SDK的<code class="docutils literal notranslate"><span class="pre">virtual</span> <span class="pre">OutputDataPtr</span> <span class="pre">SyncPredict(InputDataPtr</span> <span class="pre">input)</span> <span class="pre">=</span> <span class="pre">0;</span></code>函数，InputDataPtr定义了整个workflow的输入数据，OutputDataPtr定义了整个workflow的输出数据。</p>
<ul class="simple">
<li><p>workflows的inputs数据字段名称需要与InputDataPtr的数据字段对应，在基于数据驱动框架中，如果InputDataPtr中字段缺失，可能会导致该帧数据无法被处理。</p></li>
<li><p>workflow在计算过程中，一些中间Method可能会产生一些中间结果，这些中间结果可能也会成为其他中间Method的输入，但是可以不是整个Workflow的输出。</p></li>
</ul>
</div>
<div class="section" id="node">
<h4>3.Node定义<a class="headerlink" href="#node" title="永久链接至标题">¶</a></h4>
<p>Node是一个计算单元，它包装了Method的配置与定义，它的骨干结构如下：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
    &quot;type&quot;: &quot;node&quot;,                   // 表示Node对象
    &quot;method_type&quot;: &quot;TestMethod&quot;,      // Method类型，需要实现该Method
    &quot;unique_name&quot;: &quot;method&quot;,          // Node名称，唯一性标志
    &quot;thread_count&quot;: 3,
    &quot;inputs&quot;: [&quot;global_in&quot;],          // 输入slots
    &quot;outputs&quot;: [&quot;global_out&quot;],         // 输出slots
    &quot;method_config_file&quot;: &quot;face_pose_lmk.json&quot; // Method配置文件
    // ...
}
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type=node</span></code>表示当前节点是一个Method类型单一Node节点。用于区分<code class="docutils literal notranslate"><span class="pre">type=workflow</span></code>子workflow类型节点，详细参见<a class="reference external" href="#workflow%E5%B5%8C%E5%A5%97">子workflow定义</a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method_type</span></code>当前Node所使用的Method名称，Node初始化时，会通过一个<code class="docutils literal notranslate"><span class="pre">工厂类</span></code>来实现<code class="docutils literal notranslate"><span class="pre">method_type</span></code>到Method对象实例的初始化。MethodFactory的实现可以参考<a class="reference external" href="#2.MethodFactory%E5%AE%9A%E4%B9%89">MethodFactory定义</a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unique_name</span></code>用于唯一标识一个Node对象实例。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_count</span></code>配置Node并发副本数目，如果Method是线程安全的，可以通过设置线程数目来提高计算并发能力。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs/outputs</span></code>定义了Method的输入输出名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method_config_file</span></code>配置文件，在Method init初始化时候，会将路径传递给Method，Method内部负责读取文件并完成Method的初始化。</p></li>
</ul>
<p>除此之外，针对Method类型单Node节点，还可以配置线程调度相关参数，详细参考<a class="reference external" href="#workflow%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6">workflow调度</a>。</p>
</div>
<div class="section" id="id8">
<h4>4.子workflow定义<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>在一些复杂的业务场景中，我们可以将一个<code class="docutils literal notranslate"><span class="pre">Node</span></code>表示为一个Workflow，通过子Workflow的功能来实现Workflow嵌套。详细参见<a class="reference external" href="#workflow%E5%B5%8C%E5%A5%97">子workflow定义</a></p>
</div>
<div class="section" id="pythonworkflow">
<h4>5.基于Python来构建Workflow配置文件<a class="headerlink" href="#pythonworkflow" title="永久链接至标题">¶</a></h4>
<p>在一些复杂的业务场景中，json文件本身较为复杂，当前在缺乏可视化拖拉拽方式时候，我们也提供一个基于python脚本来构建workflow的工具，简化workflow json配置，提高workflow可复用率。详细参见<a class="reference internal" href="xstream-python-workflow.html"><span class="doc">Python-Workflow构建</span></a></p>
</div>
<div class="section" id="id9">
<h4>6.workflow配置文件可视化<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>XStream内的数据流是通过配置json文件来生成的，框架内目前已对数据流配置是否有效进行了检查，而此工具可将配置的json文件数据流向图可视化，生成一份自定义格式的文档或图片，以直观的方式展现json文件中的数据流向。详细参见<a class="reference external" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7">数据流可视化工具</a></p>
</div>
</div>
<div class="section" id="id10">
<h3>XStream开发示例<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>本节将Step by step介绍如何基于XStream完成一个业务场景下的SDK的开发。</p>
<p>基于XStream的开发，一般流程如下：</p>
<ol class="simple">
<li><p>明确需求：确定输入、输出数据；</p></li>
<li><p>功能抽象：开发Method，主要是DoProcess的逻辑；</p></li>
<li><p>构建workflow：配置基于数据流的拓扑有向图；</p></li>
<li><p>运行结果：调用xstream sdk接口获取输出结果。</p></li>
</ol>
<div class="section" id="id11">
<h4>1.需求描述<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>这里定义一个workflow，该workflow包含两个矩形框的过滤模块A、B，其中A过滤掉面积小于100的框， B过滤掉面积小于200的框。</p>
<p><img alt="xstream-sample-desc" src="../../_images/xstream-sample-desc.png" /></p>
</div>
<div class="section" id="id12">
<h4>2.Method开发<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>根据上面的功能描述，需要实现一个根据面积过滤框的Method，命名为BBoxFilter。</p>
<div class="section" id="id13">
<h5>2.1定义数据类型<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h5>
<p>BBoxFilter Method需要输入一组BBox，输出一组BBox，因此需要定义的数据类型为BBox。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box.h</span>
<span class="k">namespace</span> <span class="n">hobot</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">vision</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dtype</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">BBox_</span> <span class="p">{</span>
  <span class="kr">inline</span> <span class="n">BBox_</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kr">inline</span> <span class="n">BBox_</span><span class="p">(</span><span class="n">Dtype</span> <span class="n">x1_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">y1_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">x2_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">y2_</span><span class="p">,</span> <span class="kt">float</span> <span class="n">score_</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">,</span>
               <span class="kt">int32_t</span> <span class="n">id_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">category_name_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x1_</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y1_</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x2_</span><span class="p">;</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y2_</span><span class="p">;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">id_</span><span class="p">;</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">score_</span><span class="p">;</span>
    <span class="n">category_name</span> <span class="o">=</span> <span class="n">category_name_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">Width</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">Height</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">CenterX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">CenterY</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">Dtype</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dtype</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dtype</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dtype</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">category_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">BBox_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">BBox</span><span class="p">;</span>
<span class="p">}</span> 
</pre></div>
</div>
<p>Note: 为了统一基础数据结构定义，我们在vision_type中预定义了一组基础数据类型，包括检测框BBox、关键点Landmark、人脸3DPose信息、基础图像帧表示等，你可以直接复用，详细参考<code class="docutils literal notranslate"><span class="pre">xstream/vision_type</span></code>目录。</p>
</div>
<div class="section" id="id14">
<h5>2.2数据类型封装<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h5>
<p>基于<code class="docutils literal notranslate"><span class="pre">XStreamData</span></code>将自定义数据类型需要封装为在XStream数据表示，从而支持在XStream中流转。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box.h</span>
<span class="k">typedef</span> <span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="o">&gt;</span> <span class="n">BBox</span><span class="p">;</span>
</pre></div>
</div>
<p>输入输出是一组BBox，因此是一个BaseDataVector, 构成一个BBox数组的方式为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
<span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">105</span><span class="p">));</span>
<span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
<span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
<span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox2</span><span class="p">(</span><span class="k">new</span> <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">68</span><span class="p">));</span>
<span class="n">bbox2</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
<span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox2</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h5>2.3Method实现<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h5>
<p>继承Method基类，实现BBoxFilter Method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box_filter.h</span>
<span class="cp">#include</span> <span class="cpf">&quot;hobotxstream/method.h&quot;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">BBoxFilter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Method</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 价值json配置参数，完成method初始化</span>
  <span class="kt">int</span> <span class="n">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">config_file_path</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="c1">// 数据处理函数，第一个参数是输入数据（双重vector，外层vector表示batch是多帧的输入</span>
  <span class="c1">// 内层的vector表示单帧的数据列表），</span>
  <span class="c1">// Note：由于目前XStream框架接口并没有支持Batch模式，外层的vector恒等于1</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="n">DoProcess</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">InputParamPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="c1">// 析构</span>
  <span class="kt">void</span> <span class="nf">Finalize</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
  <span class="c1">// 动态改变Method运行参数配置</span>
  <span class="kt">int</span> <span class="nf">UpdateParameter</span><span class="p">(</span><span class="n">InputParamPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="c1">// 获取Method运行参数配置</span>
  <span class="n">InputParamPtr</span> <span class="nf">GetParameter</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="c1">// 获取Method版本号，比如 metric_v0.4.0 或者 MD112 等</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetVersion</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;BBoxFilter_test_v0.0.1&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 当workflow的profile状态发生变化时，调用该函数.</span>
  <span class="kt">void</span> <span class="n">OnProfilerChanged</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="c1">// 过滤bbox的面积阈值</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">area_threshold_</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace xstream</span>
</pre></div>
</div>
<p>DoProcess：根据面积过滤框，这里没有直接过滤掉框，而是设置了Filter状态，最终输出可以通过检查状态位得到剩余框（未被过滤的框状态应为VALID）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box_filter.cc</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="n">BBoxFilter</span><span class="o">::</span><span class="n">DoProcess</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InputParamPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BBoxFilter::DoProcess&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;&gt;</span> <span class="n">output</span><span class="p">;</span>
  <span class="n">output</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 当前不支持batch模式，batch恒等于1</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">in_batch_i</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">out_batch_i</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">out_batch_i</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">in_batch_i</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;input size: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">in_batch_i</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 只支持n个输入，输入格式是BBox的数组</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">in_batch_i</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">in_rects</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">BaseDataVector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">in_batch_i</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="n">assert</span><span class="p">(</span><span class="s">&quot;BaseDataVector&quot;</span> <span class="o">==</span> <span class="n">in_rects</span><span class="o">-&gt;</span><span class="n">type_</span><span class="p">);</span>
      <span class="k">auto</span> <span class="n">out_rects</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BaseDataVector</span><span class="o">&gt;</span><span class="p">();</span>
      <span class="n">out_batch_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">BaseData</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_rects</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">in_rect</span> <span class="p">:</span> <span class="n">in_rects</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="o">&gt;</span><span class="p">(</span><span class="n">in_rect</span><span class="p">);</span>
        <span class="c1">// 因为BBoxFilter_A和BBoxFilter_B使用智能指针指向同一份输入数据，为避免两个Filter在一个处理完成后修改State，</span>
        <span class="c1">// 影响另一个Filter处理输入数据，这里会将原来的输入数据copy一份</span>
        <span class="k">auto</span> <span class="n">out_rect</span> <span class="o">=</span> <span class="n">BaseDataPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">));</span>
        <span class="n">out_rect</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">type_</span><span class="p">;</span>
        <span class="c1">// 如果已经被之前的模块过滤掉，直接传递到输出。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">in_rect</span><span class="o">-&gt;</span><span class="n">state_</span> <span class="o">==</span> <span class="n">DataState</span><span class="o">::</span><span class="n">FILTERED</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">out_rects</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">in_rect</span><span class="p">);</span>
          <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">assert</span><span class="p">(</span><span class="s">&quot;BBox&quot;</span> <span class="o">==</span> <span class="n">out_rect</span><span class="o">-&gt;</span><span class="n">type_</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">*</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">area_threshold_</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">out_rects</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out_rect</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;B filter: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">y1</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">y2</span>
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
          <span class="c1">// 设置过滤状态，输出通过该状态过滤</span>
          <span class="n">out_rect</span><span class="o">-&gt;</span><span class="n">state_</span> <span class="o">=</span> <span class="n">DataState</span><span class="o">::</span><span class="n">FILTERED</span><span class="p">;</span>
          <span class="n">out_rects</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out_rect</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初始化时需要解析json配置参数，初始化不同的阈值，对模块A需要过滤掉面积小于100的框，a_filter.json配置为：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;threshold&quot;</span> <span class="p">:</span> <span class="mi">100</span>
<span class="p">}</span>
</pre></div>
</div>
<p>b_filter.json配置为：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;threshold&quot;</span> <span class="p">:</span> <span class="mi">200</span>
<span class="p">}</span>
</pre></div>
</div>
<p>需要注意的是Init输入参数为Json config文件路径，并不是json配置文件本身，需要先load文件然后完成json解析:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box_filter.cc</span>
<span class="kt">int</span> <span class="n">BBoxFilter</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">config_file_path</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">infile</span><span class="p">(</span><span class="n">file_path</span><span class="p">);</span>
  <span class="n">Json</span><span class="o">::</span><span class="n">Value</span> <span class="n">cfg_jv</span><span class="p">;</span>
  <span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">cfg_jv</span><span class="p">;</span>
  <span class="n">infile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
  <span class="n">area_threshold_</span> <span class="o">=</span> <span class="n">cfg_jv</span><span class="p">[</span><span class="s">&quot;threshold&quot;</span><span class="p">].</span><span class="n">asFloat</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果需要运行时更新阈值，需要实现UpdateParameter</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method/b_box_filter.cc</span>
<span class="kt">int</span> <span class="n">BBoxFilter</span><span class="o">::</span><span class="n">UpdateParameter</span><span class="p">(</span><span class="n">InputParamPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">real_ptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">FilterParam</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">real_ptr</span><span class="o">-&gt;</span><span class="n">HasThreshold</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">area_threshold_</span> <span class="o">=</span> <span class="n">real_ptr</span><span class="o">-&gt;</span><span class="n">GetThreshold</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>UpdateParameter的输入参数类型是InputParamPtr，这是XStream定义的参数类型的基类，用户需要继承该基类实现自定义的输入参数类FilterParam：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/filter_param.h</span>
<span class="cp">#include</span> <span class="cpf">&quot;hobotxsdk/xstream_data.h&quot;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_FilterParam__isset</span> <span class="p">{</span>
  <span class="n">_FilterParam__isset</span><span class="p">()</span> <span class="o">:</span> <span class="n">threshold</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">bool</span> <span class="nl">threshold</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">_FilterParam__isset</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">FilterParam</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputParam</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">FilterParam</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unique_name</span><span class="p">)</span> <span class="o">:</span> <span class="n">InputParam</span><span class="p">(</span><span class="n">unique_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threshold_</span> <span class="o">=</span> <span class="mf">2500.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">FilterParam</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Format</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;threshold&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">threshold_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">SetThreshold</span><span class="p">(</span><span class="kt">float</span> <span class="n">thres</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threshold_</span> <span class="o">=</span> <span class="n">thres</span><span class="p">;</span>
    <span class="n">is_set_</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">HasThreshold</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">is_set_</span><span class="p">.</span><span class="n">threshold</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">float</span> <span class="n">GetThreshold</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">threshold_</span><span class="p">;</span> <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">_FilterParam__isset</span> <span class="n">is_set_</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">threshold_</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace xstream</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h4>3.workflow构建<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<p>filter_workflow.json文件内容如下:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;in_bbox&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;bbox_filtered_A&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_filtered_B&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;workflow&quot;</span><span class="p">:[</span>
        <span class="p">{</span>
            <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
            <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;BBoxFilter_A&quot;</span><span class="p">,</span>
            <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;in_bbox&quot;</span>
            <span class="p">],</span>
            <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;bbox_filtered_A&quot;</span>
            <span class="p">],</span>
            <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span><span class="s2">&quot;a_filter.json&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
            <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;BBoxFilter_B&quot;</span><span class="p">,</span>
            <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;in_bbox&quot;</span>
            <span class="p">],</span>
            <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;bbox_filtered_B&quot;</span>
            <span class="p">],</span>
            <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span><span class="s2">&quot;b_filter.json&quot;</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的配置文件对应的workflow如下图:<br /><img alt="XStream-Workflow-Example" src="../../_images/xstream-workflow-sample.png" /></p>
</div>
<div class="section" id="id17">
<h4>4.功能集成<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<div class="section" id="id18">
<h5>4.1测试数据准备<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>

  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">105</span><span class="p">)));</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox2</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">68</span><span class="p">)));</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox3</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">)));</span>
  <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">bbox2</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">bbox3</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bbox1: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bbox2: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox2</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bbox3: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox3</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox2</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox3</span><span class="p">));</span>

  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
<p>如上面章节说明XStream框架中流转的数据需要基于一个公共基类BaseData扩展，产生输入数据时也需要把输入数据先转化为XStream数据表示。
这里做了两次转化：</p>
<ul class="simple">
<li><p>将基础数据类型hobot::vision::BBox转化为带XStream描述信息的表示：</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">105</span><span class="p">)));</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox2</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">68</span><span class="p">)));</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox3</span><span class="p">(</span><span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">)));</span>
  <span class="c1">// 添加数据类型描述信息</span>
  <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">bbox2</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">bbox3</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>xstream::BBox的定义为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="o">&gt;</span> <span class="n">BBox</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Workflow的输入数据为一组框，因此需要把上述3个BBox定义组织到数组中，同时数组也要转化为XStream数据表示:
BaseData的数组表示为BaseDataVector， BaseDataVector已经是BaseData的子类，可以直接转化为BaseData。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox2</span><span class="p">));</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox3</span><span class="p">));</span>
  <span class="c1">// 数据的name， 需要和定义的json workflow的输入部分name一致</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>这里需要注意的是输入数据需要添加name信息，name需要和定义的JSON workflow inputs一样，预测时即是通过该信息Feed workflow：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;in_bbox&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;bbox_filtered_A&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_filtered_B&quot;</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>XStream输入数据的数据结构为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 输入数据类型</span>
<span class="k">struct</span> <span class="n">InputData</span> <span class="p">{</span>
  <span class="c1">// 用户输入的数据，比如图片channel、时间戳、框等等</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span> <span class="n">datas_</span><span class="p">;</span>
  <span class="c1">// 当前请求自定义的参数</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InputParamPtr</span><span class="o">&gt;</span> <span class="n">params_</span><span class="p">;</span>
  <span class="c1">// 数据源 id 用于多路输入时区分输入源,单一源情况赋值为 0</span>
  <span class="kt">uint32_t</span> <span class="n">source_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 透传的数据，该数据会透传到OutputData::context_ 字段</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>输入数据存储在datas_中:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h5>4.2Method注册<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h5>
<p>XStream框架构建workflow时，调用全局MethodFactory创建对应Method实例，在使用BBoxFilter之前需要注册到MethodFactory中;</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/tutorials/stage1/method_factory.cc</span>
<span class="cp">#include</span> <span class="cpf">&quot;hobotxstream/method_factory.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;method/bbox_filter.h&quot;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">xstream</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">method_factory</span> <span class="p">{</span>
<span class="n">MethodPtr</span> <span class="n">CreateMethod</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">method_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="s">&quot;BBoxFilter&quot;</span> <span class="o">==</span> <span class="n">method_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MethodPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">BBoxFilter</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MethodPtr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace method_factory</span>
<span class="p">}</span>  <span class="c1">// namespace xstream</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h5>4.3同步预测<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h5>
<p>调用XStreamSDK的class静态接口CreateSDK, 创建一个XStreamSDK的对象，并使用SyncPredict进行同步预测。</p>
<p>构建SDK代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// xstream/tutorials/stage1/sync_main.cc文件对输入数据稍作改动，改成了循环输入10次数据。</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseData</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataPtr</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataVector</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputData</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputDataPtr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage : ./bbox_filter_main work_flow_config_file&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Example : ./bbox_filter_main ./filter_workflow.json&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">auto</span> <span class="n">config</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
  <span class="kt">float</span> <span class="n">x1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的左上角横坐标</span>
  <span class="kt">float</span> <span class="n">y1</span><span class="p">{</span><span class="mi">20</span><span class="p">};</span>  <span class="c1">// BBox(框)的左上角纵坐标</span>
  <span class="kt">float</span> <span class="n">x2</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的右上角横坐标</span>
  <span class="kt">float</span> <span class="n">y2</span><span class="p">{</span><span class="mi">50</span><span class="p">};</span>  <span class="c1">// BBox(框)的右上角纵坐标</span>
  <span class="c1">// 框的面积计算公式:(x2-x2)*(y2-y1)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;testing synchronous function&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 生成面积为{ 0, 30, 60, 90, 120, 150, 180, 210, 240,</span>
    <span class="c1">// 270 } 序列,作为BBoxFilter的输入数据</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">x2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
      <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
      <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox</span><span class="p">(</span>
          <span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)));</span>
      <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main i:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; bbox:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox</span><span class="p">));</span>

      <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
      <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

      <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
      <span class="n">ParseOutput</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">delete</span> <span class="n">flow</span><span class="p">;</span>
 
</pre></div>
</div>
<p>同步预测接口SyncPredict，传⼊输入数据后，接口会阻塞住，直到整个workflow处理完成，将workflow的结果通过函数返回值返回为⽌。该接口需要在Init()之后执⾏才有效。</p>
</div>
<div class="section" id="id21">
<h5>4.4异步预测<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h5>
<p>调用XStreamSDK的class静态接口CreateSDK, 创建一个XStreamSDK的对象，并使用AsyncPredict进行异步预测。</p>
<p>其中涉及以下两个接口：</p>
<ul class="simple">
<li><p>接口：</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">int64_t</span> <span class="nf">AsyncPredict</span><span class="p">(</span><span class="n">InputDataPtr</span> <span class="n">input</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：异步预测接口，AsyncPredict接⼝调⽤后立即返回，结果通过SetCallback设置的回调函数捕获。<br />Note:该接⼝需要在Init()之后执⾏才有效。</p>
<ul class="simple">
<li><p>设置异步回调接口</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">int</span> <span class="nf">SetCallback</span><span class="p">(</span><span class="n">XStreamCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：使⽤异步分析接口时，设置SetCallback才有效。
将name设置为默认值，通过该接口可以设置整个workflow处理完成后的回调函数；
将name设置为某个Node的unique名字，通过该接口可以设置某个method实例处理完成后的回调函数。</p>
<p>基于异步接口创建sdk的方式：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// xstream/tutorials/stage1/async_main.cc</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseData</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataPtr</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataVector</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputData</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">InputDataPtr</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Stage1Async</span><span class="o">::</span><span class="n">Callback</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage : ./bbox_filter_main work_flow_config_file&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Example : ./bbox_filter_main ./filter_workflow.json&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">auto</span> <span class="n">config</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
  <span class="n">Callback</span> <span class="n">callback</span><span class="p">;</span>
  <span class="c1">// 整个Workflow回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
  <span class="c1">// BBoxFilter_A回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">),</span>
      <span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">);</span>
  <span class="c1">// BBoxFilter_B回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">),</span>
      <span class="s">&quot;BBoxFilter_B&quot;</span><span class="p">);</span>

  <span class="c1">// Get Method Version</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BBoxFilter_A Method Version : &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">GetVersion</span><span class="p">(</span><span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">x1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的左上角横坐标</span>
  <span class="kt">float</span> <span class="n">y1</span><span class="p">{</span><span class="mi">20</span><span class="p">};</span>  <span class="c1">// BBox(框)的左上角纵坐标</span>
  <span class="kt">float</span> <span class="n">x2</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// BBox(框)的右上角横坐标</span>
  <span class="kt">float</span> <span class="n">y2</span><span class="p">{</span><span class="mi">50</span><span class="p">};</span>  <span class="c1">// BBox(框)的右上角纵坐标</span>
  <span class="c1">// 框的面积计算公式:(x2-x2)*(y2-y1)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;testing synchronous function&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 生成面积为{ 0, 30, 60, 90, 120, 150, 180, 210, 240,</span>
    <span class="c1">// 270 } 序列,作为BBoxFilter的输入数据</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">x2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
      <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
      <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox</span><span class="p">(</span>
          <span class="k">new</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)));</span>
      <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;i:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; bbox:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bbox</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox</span><span class="p">));</span>

      <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;in_bbox&quot;</span><span class="p">;</span>
      <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

      <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
      <span class="c1">// waiting for async function done</span>
      <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">delete</span> <span class="n">flow</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>定义和设置 callback</strong>：</p>
<ul>
<li><p>定义用户的Callback类,实现一个类似OnCallback函数，参数类型为<code class="docutils literal notranslate"><span class="pre">xstream::OutputDataPtr</span> <span class="pre">output</span></code>，用来处理XStream worflow的回调结果。代码:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Callback</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">OnCallback</span><span class="p">(</span><span class="n">xstream</span><span class="o">::</span><span class="n">OutputDataPtr</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ParseOutput</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>设置callback</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Callback</span><span class="o">::</span><span class="n">Callback</span> <span class="n">callback</span><span class="p">;</span>
<span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span>
  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MethodCallback</span><span class="o">::</span><span class="n">Callback</span><span class="o">::</span><span class="n">OnCallback</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id22">
<h5>4.5预测结果解析<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span> <span class="c1">// xstream/tutorials/stage1/sync_main.cc</span>
  <span class="kt">void</span> <span class="nf">ParseOutput</span><span class="p">(</span><span class="n">xstream</span><span class="o">::</span><span class="n">OutputDataPtr</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">xstream</span><span class="o">::</span><span class="n">BaseDataVector</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=====================&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;seq: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">sequence_id_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;output_type: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">output_type_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;method_unique_name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">unique_name_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error_code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">error_code_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error_detail_: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">error_detail_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;datas_ size: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">data</span> <span class="p">:</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">error_code_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;data error: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">error_code_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;data type_name : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">BaseDataVector</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">BaseDataVector</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;pdata size: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Output BBox &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">xstream_box</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="o">&gt;&gt;</span><span class="p">(</span>
                <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xstream_box</span><span class="o">-&gt;</span><span class="n">state_</span> <span class="o">==</span> <span class="n">xstream</span><span class="o">::</span><span class="n">DataState</span><span class="o">::</span><span class="n">VALID</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">xstream_box</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">xstream_box</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">y1</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">xstream_box</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">xstream_box</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">y2</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>输出数据结构为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// xstream/framework/include/hobotxsdk/xstream_data.h</span>
<span class="c1">// 输出数据类型</span>
<span class="k">struct</span> <span class="n">OutputData</span> <span class="p">{</span>
  <span class="c1">// 错误码</span>
  <span class="kt">int</span> <span class="n">error_code_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 错误信息</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error_detail_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="c1">// 当该OutputData为给某个Method的定向回调结果时，该字段用于指示Method名称</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unique_name_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="c1">// 多路输出结果名称</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output_type_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="c1">// 输出结果</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span> <span class="n">datas_</span><span class="p">;</span>
  <span class="c1">// 从InputData透传过来的数据</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="c1">// 该结果的序列号</span>
  <span class="kt">int64_t</span> <span class="n">sequence_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 该结果是属于那个输入源产生的结果</span>
  <span class="kt">uint32_t</span> <span class="n">source_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">global_sequence_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">OutputData</span><span class="o">&gt;</span> <span class="n">OutputDataPtr</span><span class="p">;</span>
</pre></div>
</div>
<p>datas_字段存储了输出的结果，对于该workflow保护两个输出：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s">&quot;inputs&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s">&quot;in_bbox&quot;</span><span class="p">],</span>  <span class="c1">// 输入的数据list，它是workflow里面定义的inputs的子集</span>
  <span class="s">&quot;outputs&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s">&quot;bbox_filtered_A&quot;</span><span class="p">,</span>
              <span class="s">&quot;bbox_filtered_B&quot;</span><span class="p">],</span>  <span class="c1">// 输出的数据list，它是workflow里面定义的outputs的一个子集</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>每个输出都是一个框的数组，解析的数据结果层次为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDataPtr</span><span class="o">&gt;</span>
<span class="o">--&gt;</span> <span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">BaseDataVector</span><span class="p">)</span>
<span class="o">--&gt;</span> <span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="o">--&gt;</span> <span class="n">xstream_data</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">(</span><span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h5>4.6动态更新配置<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h5>
<p>如果想动态更新BBoxFilter的阈值，可以调用UpdateConfig接口完成。</p>
<ul class="simple">
<li><p>接口</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">int</span> <span class="nf">UpdateConfig</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">,</span> <span class="n">InputParamPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：用于设置method的参数，最终会通过调用对应的Method-&gt;UpdateParameter(InputParamPtr ptr)接口，完成Method参数的更新。<br />&#64;unique_name：指定需要更新配置的node的unique name;<br />&#64;ptr：需要更新配置信息</p>
<p>调用GetConfig可以获得Node当前参数配置。</p>
<ul class="simple">
<li><p>接口</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="n">InputParamPtr</span> <span class="nf">GetConfig</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">unique_name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：获取某个method的参数，最终会调用对应的Method-&gt;GetParameter()返回method配置信息。</p>
<ul class="simple">
<li><p>代码</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;testing aysnc function&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;***********************&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unique_name</span><span class="p">(</span><span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">);</span>
      <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">FilterParam</span><span class="o">&gt;</span><span class="p">(</span><span class="n">unique_name</span><span class="p">);</span>
      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">SetThreshold</span><span class="p">(</span><span class="mf">90.0</span><span class="p">);</span>
      <span class="n">flow</span><span class="o">-&gt;</span><span class="n">UpdateConfig</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">unique_name_</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">auto</span> <span class="n">node_config</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">GetConfig</span><span class="p">(</span><span class="s">&quot;BBoxFilter_A&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node_config</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">real_ptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">xstream</span><span class="o">::</span><span class="n">FilterParam</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">node_config</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;threshold:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">real_ptr</span><span class="o">-&gt;</span><span class="n">GetThreshold</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id24">
<h3>XStream高阶功能<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>本节主要介绍了一下XStream Framework内部一些高阶功能：多路输入，多路输出，Node输出回调，workflow线程调度，Method运行参数控制，内存资源释放，超时预警机制，workflow嵌套，性能统计，数据流可视化工具。</p>
<div class="section" id="id25">
<h4>多路输入<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">XStreamSDK::Predict</span></code>接口支持通过指定InputData中<code class="docutils literal notranslate"><span class="pre">source_id_</span></code>字段来表示输入源，进而支持多路视频输入，source_id_默认值为0，代表第一路。同时计算结果OutputData中<code class="docutils literal notranslate"><span class="pre">source_id_</span></code>字段与输入数据对应相同；
Workflow配置文件中通过字段”source_number”表示输入源数目，默认为1。注意source_id_的范围需要在[0, source_number-1]内。</p>
<p><strong>多路输入示例配置文件</strong>：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;source_number&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box_filter&quot;</span><span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h4>多路输出<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<p>XStream Framework中每个Node在计算过程中都会产生一些中间结果，这些中间结果可以作为其他Node计算节点的输入，或作为最后输出，或成为无效数据被清理。当这些中间输出作为最终workflow输出时，每一帧的中间结果都需要等到所有输出数据都ready以后再整体作为OutputData数据输出，如果workflow中部分Node计算复杂度较大会导致前面部分输出被延迟。</p>
<p><strong>多路输出功能</strong>，为缩短一些output数据的返回等待时间。通过该机制可以将输出数据分为多路输出，对于每一路数据达到Ready状态时，即可通过回调函数返回结果。</p>
<p>多路输出一般配合XStream SDK的异步调用方式使用，通过SetCallback接口设置回调函数，每路的输出通过该回调函数返回给调用者。若用户在配置多路输出workflow的同时采取同步调用的方式，需要注意需要配合使用SyncPredict2的同步调用接口获取输出结果。</p>
<p>多路输出的workflow配置文件可参考下面示例，与一般配置的差别仅在于需要在”outputs”字段将输出数据分组，并添加”output_type”字段表明该路输出的名称。</p>
<p><strong>多路输出workflow配置文件</strong>：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;output_type&quot;</span><span class="p">:</span> <span class="s2">&quot;out1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span><span class="s2">&quot;face_head_box_filter&quot;</span><span class="p">,</span> <span class="s2">&quot;face_head_box_filter2&quot;</span><span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;output_type&quot;</span><span class="p">:</span> <span class="s2">&quot;out2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span><span class="s2">&quot;face_head_box_filter3&quot;</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_3&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter3&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h4>Node输出回调<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h4>
<p>XStream Framework中每个Node在计算过程中都会产生一些中间结果，在一些应用场景下需要将特定Node的结果输出，因此，XStream Framework内提供了”Node输出回调”的机制。<strong>注意：该机制仅支持在XStream SDK的异步调用方式使用。</strong>
同时需要配合使用<code class="docutils literal notranslate"><span class="pre">XStreamSDK::SetCallback</span></code>函数设置指定Node节点的回调函数，需要注意，使用SetCallback函数为指定Node设置回调函数需要在sdk对象Init之后执行，否则Node节点name未初始化，无法设置成功。</p>
<p>若需要对下面workflow中的”BBoxFilter_1”，”BBoxFilter_2”节点分别设置不同的回调函数，示例代码如下：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box_filter2&quot;</span><span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">OnCallback</span><span class="p">(</span><span class="n">xstream</span><span class="o">::</span><span class="n">OutputDataPtr</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理输出数据</span>
<span class="p">}</span>

<span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
  <span class="c1">// 设置workflow配置文件</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="s">&quot;./configs/filter.json&quot;</span><span class="p">);</span>
  <span class="c1">// 设置workflow输出回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span><span class="n">OnCallback</span><span class="p">);</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
  <span class="c1">// 设置BBoxFilter_1输出回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span><span class="n">OnCallback</span><span class="p">,</span> <span class="s">&quot;BBoxFilter_1&quot;</span><span class="p">);</span>
  <span class="c1">// 设置BBoxFilter_2输出回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span><span class="n">OnCallback</span><span class="p">,</span> <span class="s">&quot;BBoxFilter_2&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h4>workflow线程调度<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<p>XStream内部通过多线程的方式来提高调度和执行并发度，其中涉及线程包括以下两大类：</p>
<ul class="simple">
<li><p>两个框架调度线程：包括workflow调度线程<code class="docutils literal notranslate"><span class="pre">sched_upper</span></code>和Node调度线程<code class="docutils literal notranslate"><span class="pre">sched_down</span></code>。</p></li>
<li><p>Node计算线程池：在workflow构建中，我们可以配置每个Node的计算副本数，通过线程池来提高Node计算并发度，降低计算延迟。</p></li>
</ul>
<p>对于这两类线程，除了在workflow构建中设置Node计算副本数以外，XStream还支持设置线程调度策略，调整线程优先级以及对线程进行绑定。</p>
<div class="section" id="id29">
<h5>1.调度策略与优先级<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h5>
<p>支持设置线程调度策略包括：</p>
<ul>
<li><p><strong>SCHED_OTHER or SCHED_NORMAL</strong>: 默认调度优先级，不支持优先级设置，优先级恒为0。Ready的线程在等待队列等待时间越长，优先级越高；</p></li>
<li><p><strong>SCHED_FIFO</strong>：一种实时调用策略，可设置线程优先级范围<strong>1~99</strong>，值越大优先级越高；当SCHED_FIFO的线程状态为runable时，会立即抢占SCHED_OTHER的线程;如果一个SCHED_FIFO线程被一个更高优先级的线程抢占，该线程会放在相同优先级线程的队首；当一个SCHED_FIFO的线程状态变成runnable时，该线程放在相同优先级线程的队尾；</p></li>
<li><p><strong>SCHED_RR</strong>：一种实时调度策略，可设置线程优先级范围<strong>1~99</strong>，值越大优先级越高；SCHED_RR调度策略本身是SCHED_FIFO的简单增强版，区别在于对于相同优先级的线程，SCHED_RR对于相同优先级的线程也是采用时间片轮转的方式，一个线程做完自己的时间片之后就放在该优先级线程的队尾，反之SCHED_FIFO不会主动让出线程；</p></li>
<li><p><strong>SCHED_BATCH</strong>：为批处理任务设计的优先级调度策略，SCHED_IDLE的线程优先级特别低；跟SCHED_OTHER调度策略一样，优先级恒为0，不能设置；</p>
<p>关于线程调度策略详细参考：<a class="reference external" href="http://man7.org/linux/man-pages/man7/sched.7.html">http://man7.org/linux/man-pages/man7/sched.7.html</a></p>
</li>
</ul>
<p>针对XStream内部两类线程，都支持设置它的调度策略和调度优先级，实例如下：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box_filter2&quot;</span><span class="p">],</span>
  <span class="nt">&quot;optional&quot;</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="nt">&quot;sched_upper&quot;</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="nt">&quot;policy&quot;</span><span class="p">:</span> <span class="s2">&quot;SCHED_FIFO&quot;</span><span class="p">,</span>
      <span class="nt">&quot;priority&quot;</span><span class="p">:</span> <span class="mi">30</span>
    <span class="p">},</span>
    <span class="nt">&quot;sched_down&quot;</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="nt">&quot;policy&quot;</span><span class="p">:</span> <span class="s2">&quot;SCHED_FIFO&quot;</span><span class="p">,</span>
      <span class="nt">&quot;priority&quot;</span><span class="p">:</span> <span class="mi">30</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_list&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
      <span class="nt">&quot;thread_priority&quot;</span><span class="p">:</span>
      <span class="p">{</span>
        <span class="nt">&quot;policy&quot;</span><span class="p">:</span> <span class="s2">&quot;SCHED_FIFO&quot;</span><span class="p">,</span>
        <span class="nt">&quot;priority&quot;</span><span class="p">:</span> <span class="mi">10</span>
      <span class="p">},</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;sched_fifo0.json&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_list&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="nt">&quot;thread_priority&quot;</span><span class="p">:</span>
      <span class="p">{</span>
        <span class="nt">&quot;policy&quot;</span><span class="p">:</span> <span class="s2">&quot;SCHED_FIFO&quot;</span><span class="p">,</span>
        <span class="nt">&quot;priority&quot;</span><span class="p">:</span> <span class="mi">20</span>
      <span class="p">},</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;sched_fifo1.json&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意：关于优先级，建议upper和down两个调度线程的的优先级高于每个method node的线程优先级。同时Node中多个线程只能配置为相同的优先级，如果多个method node共享同一个线程，在拓扑靠后（workflow本身即是按拓扑有序排列的，所以就是workflow每个node的排序靠后的）的method node设置的优先级有效；</p>
</div>
<div class="section" id="id30">
<h5>2.Node计算线程绑定<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h5>
<p>通过提高Node的计算副本数thread_count来增加计算并发度同时，本身也增加来任务计算线程数，进而因线程抢占而影响计算效率。</p>
<p>因此框架也支持指定了node执行线程index的数组，基于thread_list可以实现多个node之间共享执行线程。通过该方法既满足计算并发度，又避免因为小的计算任务导致线程膨胀。</p>
<p>实例参考上述<code class="docutils literal notranslate"><span class="pre">thread_list</span></code>设置方式。</p>
</div>
</div>
<div class="section" id="id31">
<h4>Method运行参数控制<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h4>
<p>在workflow正常运行过程中，可能会因为一些需求需要对单次计算选择临时跳过一些Node计算节点。例如, 通过外部传入人脸照片，提取特征时，创建底库时, 需要运行人脸检测，特征提取计算, 但不需要再进行人脸mot跟踪, mot method的计算节点就可以关闭。针对这个需求，XStream提供了几种方式：</p>
<ul class="simple">
<li><p>Invalid模式: 将Node输出设置为无效状态，默认节点输出数据状态<code class="docutils literal notranslate"><span class="pre">state=DataState::INVALID</span></code>，跳过Node节点计算。</p></li>
<li><p>UsePreDefine模式: 拷贝先验数据到输出，要求先验数据个数与输出数据个数一致, 且类型相同。试用于模拟, 测试等场景。</p></li>
<li><p>PassThrough模式: 直接将关闭节点的输入数据当做输出数据，即透传输入数据到输出，要求输入数据与输出数据个数一致，且类型相同。</p></li>
<li><p>BestEffortPassThrough模式: PassThrough模式升级版本，如果关闭节点的输入数据多于或等于输出数据，则按顺序将输入数据拷贝到输出数据；如果输入数据少于输出数据, 则多余的输出为Invalid的BaseData。</p></li>
</ul>
<div class="section" id="invalid-mode">
<h5>1.Invalid Mode<a class="headerlink" href="#invalid-mode" title="永久链接至标题">¶</a></h5>
<p>下面workflow输入数据是face_head_box, 最终输出数据是face_head_box_filter_3，face_head_box_filter_5。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;max_running_count&quot;</span><span class="p">:</span> <span class="mi">10000</span><span class="p">,</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_head_box_filter_2&quot;</span><span class="p">,</span> <span class="s2">&quot;face_head_box_filter_3&quot;</span><span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter_1&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_2&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter_1&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter_2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
	  <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;BBoxFilter_3&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter_2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;face_head_box_filter_3&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此时希望暂时停止BBoxFilter_3的运行，</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  InputDataPtr inputdata(new InputData());
  BaseDataVector *data(new BaseDataVector);
  HobotXStream::BBox *bbox1(new HobotXStream::BBox(hobot::vision::BBox(0, 0, 40, 40)));
  bbox1-&gt;type_ = &quot;BBox&quot;;
  data-&gt;name_ = &quot;face_head_box&quot;;
  data-&gt;datas_.push_back(BaseDataPtr(bbox1));
  inputdata-&gt;datas_.push_back(BaseDataPtr(data));
  HobotXStream::InputParamPtr invalidFilter3(new HobotXStream::DisableParam(&quot;BBoxFilter_3&quot;， Mode::Invalid));
  inputdata-&gt;params_.push_back(invalidFilter3);

  out = flow-&gt;SyncPredict(inputdata);
  callback.OnCallback(out);
</pre></div>
</div>
<p>对应的Workflow结构图如下所示：</p>
<p><img alt="Invalid2" src="../../_images/Invalid2.png" /></p>
<p>此时”BBoxFilter_3”节点输出数据被标记为INVALID，即data状态设置为<code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">=</span> <span class="pre">DataState::INVALID</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>============Output Call Back============
—seq: 1
—output_type: __NODE_WHOLE_OUTPUT__
—error_code: 0
—error_detail_: 
—datas_ size: 2
——output data face_head_box_filter_2 state:0
——data type:BaseDataVector name:face_head_box_filter_2
——output data face_head_box_filter_3 state:4
——data type:BaseData name:face_head_box_filter_3
============Output Call Back End============
</pre></div>
</div>
<p><strong>注意</strong>：将一个Node节点设置为INVALID，需要保证该节点输出不被其他Node节点所依赖，或者依赖该节点输出的后继节点可以处理输入数据状态”INVALID”的情况，否则会造成计算失败。
比如，在上面实例中，如果将”BBoxFilter_2”节点设置为Invalid Mode，而”BBoxFilter_2”输出被”BBoxFilter_3”依赖，导致”BBoxFilter_3”节点的输出face_head_box_filter_3为空，最后整个workflow输出<code class="docutils literal notranslate"><span class="pre">error_code:-2002</span> <span class="pre">HOBOTXSTREAM_ERROR_OUTPUT_NOT_READY</span></code>的计算错误。</p>
</div>
<div class="section" id="use-predefined-mode">
<h5>2.Use Predefined Mode<a class="headerlink" href="#use-predefined-mode" title="永久链接至标题">¶</a></h5>
<p>Use Predefined模型与Invalid模型类似，它是通过人工指定相关Node的输出字段内容，而跳过Node节点计算。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">)));</span>
  <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;face_head_box&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParamPtr</span>
      <span class="n">pre_define</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="p">(</span>
          <span class="s">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
          <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="o">::</span><span class="n">Mode</span><span class="o">::</span><span class="n">UsePreDefine</span><span class="p">));</span> 
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">pre_data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">pre_bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)));</span>
  <span class="n">pre_bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">pre_data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;face_head_box&quot;</span><span class="p">;</span>
  <span class="n">pre_data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">pre_bbox1</span><span class="p">));</span>
  <span class="n">pre_define</span><span class="o">-&gt;</span><span class="n">pre_datas_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">pre_data</span><span class="p">));</span>

  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">params_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pre_define</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="passthrough-mode">
<h5>3.PassThrough Mode<a class="headerlink" href="#passthrough-mode" title="永久链接至标题">¶</a></h5>
<p>PassThrough Mode模式是直接将输入数据写为输出数据，从而跳过节点计算。PassThrough模式要求Node节点的输入数据和输出数据个数(InputData.data_.size())是一致的。</p>
<p>对于该Workflow，我们尝试用PassThrough方式关闭<code class="docutils literal notranslate"><span class="pre">PostBoxFilter_2</span></code>节点。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">)));</span>
  <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;face_head_box&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">InputParamPtr</span>
      <span class="n">pass_through</span><span class="p">(</span><span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="p">(</span><span class="s">&quot;PostBoxFilter_2&quot;</span><span class="p">,</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="o">::</span><span class="n">Mode</span><span class="o">::</span><span class="n">PassThrough</span><span class="p">));</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">params_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pass_through</span><span class="p">);</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
</pre></div>
</div>
<p>此时实际运行时，Workflow结构如下：</p>
<p><img alt="PassThrough-2" src="../../_images/PassThrough-2.png" /></p>
</div>
<div class="section" id="best-effort-passthrough-mode">
<h5>4.Best Effort PassThrough Mode<a class="headerlink" href="#best-effort-passthrough-mode" title="永久链接至标题">¶</a></h5>
<p>PassThrough Mode模式将输入直接透传到输出，但是要求输入数据和输出数据字段数目一致。但是实际场景下，输入数据和输出数据并不匹配。</p>
<p>Best Effort PassThrough Mode模式支持在输入数据字段多于输出字段数目时，只透传前面的数据字段。如果输入数据字段少于输出字段数目时，则多余的输出字段写为Invalid。</p>
<p>BestEffortPassThrough是PassThrough的改进版本，多数情况下更推荐使用estEffortPassThrough模式。使用方式如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">InputDataPtr</span> <span class="nf">inputdata</span><span class="p">(</span><span class="k">new</span> <span class="n">InputData</span><span class="p">());</span>
  <span class="n">BaseDataVector</span> <span class="o">*</span><span class="nf">data</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseDataVector</span><span class="p">);</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span> <span class="o">*</span><span class="n">bbox1</span><span class="p">(</span><span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span>
    <span class="n">hobot</span><span class="o">::</span><span class="n">vision</span><span class="o">::</span><span class="n">BBox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">)));</span>
  <span class="n">bbox1</span><span class="o">-&gt;</span><span class="n">type_</span> <span class="o">=</span> <span class="s">&quot;BBox&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">name_</span> <span class="o">=</span> <span class="s">&quot;face_head_box&quot;</span><span class="p">;</span>
  <span class="n">data</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">bbox1</span><span class="p">));</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">datas_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BaseDataPtr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">params_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">HobotXStream</span><span class="o">::</span><span class="n">InputParamPtr</span>
    <span class="n">b_effort_pass_through</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="p">(</span>
        <span class="s">&quot;BBoxFilter_1&quot;</span><span class="p">,</span>
        <span class="n">HobotXStream</span><span class="o">::</span><span class="n">DisableParam</span><span class="o">::</span><span class="n">Mode</span><span class="o">::</span><span class="n">BestEffortPassThrough</span><span class="p">));</span>
  <span class="n">inputdata</span><span class="o">-&gt;</span><span class="n">params_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b_effort_pass_through</span><span class="p">);</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id32">
<h4>内存资源释放<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h4>
<p>在XStream Framework中，一般情况下，各个Node节点的输入输出数据Slot会等整个workflow流程结束后才释放。而实际过程中，有些中间结果在驱动后续节点计算完成后就不再需要，或者整个workflow中根本没有用到一些中间结果，这种情况下就可以利用”内存资源释放”机制，在workflow的计算过程中就可以将这些内存资源释放出来。XStream Framework中该机制默认是关闭的，使用需要配合<code class="docutils literal notranslate"><span class="pre">XStreamSDK::SetConfig(&quot;free_framedata&quot;,</span> <span class="pre">&quot;on&quot;)</span></code>接口以打开该功能，详细可参考以下示例。</p>
<p>在下面的workflow中，”PreMethod”节点输出数据”tmp_data_1”和”tmp_data_2”，”tmp_data_1”是未使用的中间结果，在”PreMethod”节点计算结束后即可释放。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;input_data&quot;</span><span class="p">],</span>
  <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;output_data&quot;</span><span class="p">],</span>
  <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;PreMethod&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;PreMethod&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;input_data&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;tmp_data_1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tmp_data_2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;PostMethod&quot;</span><span class="p">,</span>
      <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;PostMethod&quot;</span><span class="p">,</span>
      <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;tmp_data_2&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;output_data&quot;</span>
      <span class="p">],</span>
      <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;null&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p><img alt="内存资源释放" src="../../_images/free_memory.png" /></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
  <span class="c1">// 设置workflow配置文件</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="s">&quot;./configs/config.json&quot;</span><span class="p">);</span>
  <span class="c1">// 初始化</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
  <span class="c1">// 设置workflow输出回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span><span class="n">OnCallback</span><span class="p">);</span>
  <span class="c1">// 打开内存释放</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;free_framedata&quot;</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">);</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h4>超时预警机制<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h4>
<p>用户在调用XStream Framework中的预测接口向框架输入一帧数据后，该帧数据在各个节点中的计算耗时与用户定义在节点内的处理逻辑有关。尤其在使用异步预测接口时，向框架送入输入数据后，用户只能通过回调函数知悉框架内数据的处理。因此可以使用”超时预警机制”，当一帧数据在框架内耗时超长，框架内会输出警告日志，并打印出该帧数据的输入源、帧id信息。</p>
<p>同样，框架内默认未开启该功能，需要配合<code class="docutils literal notranslate"><span class="pre">XStreamSDK::SetConfig(&quot;time_monitor&quot;,</span> <span class="pre">&quot;value&quot;)</span></code>接口使用，其中”value”表示整数时间间隔，单位是秒。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>  <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="n">xstream</span><span class="o">::</span><span class="n">XStreamSDK</span><span class="o">::</span><span class="n">CreateSDK</span><span class="p">();</span>
  <span class="c1">// 设置workflow配置文件</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;config_file&quot;</span><span class="p">,</span> <span class="s">&quot;./configs/config.json&quot;</span><span class="p">);</span>
  <span class="c1">// 初始化</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>
  <span class="c1">// 设置workflow输出回调函数</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetCallback</span><span class="p">(</span><span class="n">OnCallback</span><span class="p">);</span>
  <span class="c1">// 设置超时3秒预警</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;time_monitor&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">);</span>
  <span class="n">flow</span><span class="o">-&gt;</span><span class="n">AsyncPredict</span><span class="p">(</span><span class="n">inputdata</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h4>workflow嵌套<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<p>Workflow骨干架构中，Workflow内容可以是Node类型节点，也可以是一个子Workflow。通过子Workflow可以实现一个更高粒度的复用，提供workflow复用价值。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
	&quot;name&quot;: &quot;xxx&quot;,         // workflow名称，需唯一化
	&quot;type&quot;: &quot;workflow&quot;,    // 表示Workflow对象
	&quot;inputs&quot;: [],          // 输入slots名称
	&quot;outputs&quot;: [],         // 输出slots名称
	&quot;workflow&quot;: [          // Workflow内容，包括Node或Workflow对象(子workflow)
	]
}
</pre></div>
</div>
<p>子Workflow的引入，是参考了编程语言中函数的设计思想：</p>
<ul class="simple">
<li><p>子workflow是个配置文件，它组装了多个功能Method，该文件可以被多个父Workflow引用。</p></li>
<li><p>子Workflow被引用过程中，也支持参数化，类似传统编程语言中函数和函数参数。</p></li>
</ul>
<p>下面一个使用子workflow配置实例：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;workflow&quot;</span><span class="p">,</span>
    <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;image&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;face_box&quot;</span><span class="p">,</span>
        <span class="s2">&quot;vehicle_box&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;workflow&quot;</span><span class="p">:[</span>
        <span class="p">{</span>
            <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;node&quot;</span><span class="p">,</span>
            <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;fasterrcnndet&quot;</span><span class="p">,</span>
            <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;FasterRCNNMethod&quot;</span><span class="p">,</span>
            <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;image&quot;</span>
            <span class="p">],</span>
            <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                <span class="s2">&quot;face_box&quot;</span>
            <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;template_ref&quot;</span><span class="p">,</span>
            <span class="nt">&quot;template_name&quot;</span><span class="p">:</span><span class="s2">&quot;cnn.tpl&quot;</span><span class="p">,</span>
            <span class="nt">&quot;parameters&quot;</span><span class="p">:{</span>
                <span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;vehicle_cnn&quot;</span><span class="p">,</span>
                <span class="nt">&quot;pre_method&quot;</span><span class="p">:</span><span class="s2">&quot;VehiclePreProcess&quot;</span><span class="p">,</span>
                <span class="nt">&quot;post_method&quot;</span><span class="p">:</span><span class="s2">&quot;VehiclePostProcess&quot;</span><span class="p">,</span>
                <span class="nt">&quot;input&quot;</span><span class="p">:</span><span class="s2">&quot;image&quot;</span><span class="p">,</span>
                <span class="nt">&quot;output&quot;</span><span class="p">:</span><span class="s2">&quot;vehicle_box&quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>父workflow命名为main，它包含一个Node类型的Method算子和一个template_ref类型的子workflow。</p></li>
<li><p>子workflow为<code class="docutils literal notranslate"><span class="pre">cnn.tpl</span></code>,它是一个与父workflow文件同目录的文件。</p></li>
<li><p>parameters为一个对象，其中每一个字段都将为参数值传递给子workflow。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cnn.tpl</span></code>子workflow配置定义如下：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;template&quot;</span><span class="p">,</span>
    <span class="nt">&quot;template_name&quot;</span><span class="p">:</span><span class="s2">&quot;cnn.tpl&quot;</span><span class="p">,</span>
    <span class="nt">&quot;parameters&quot;</span><span class="p">:[</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pre_method&quot;</span><span class="p">,</span>
        <span class="s2">&quot;post_method&quot;</span><span class="p">,</span>
        <span class="s2">&quot;inputs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;outputs&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;template&quot;</span><span class="p">:{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;${name}&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;workflow&quot;</span><span class="p">,</span>
        <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
            <span class="s2">&quot;${inputs}&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
            <span class="s2">&quot;${outputs}&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;workflow&quot;</span><span class="p">:[</span>
            <span class="p">{</span>
                <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;node&quot;</span><span class="p">,</span>
                <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;${pre_method}&quot;</span><span class="p">,</span>
                <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span>
                <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;inputs&quot;</span>
                <span class="p">],</span>
                <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;pre_out0&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;pre_out1&quot;</span>
                <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;node&quot;</span><span class="p">,</span>
                <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;CNNMethod&quot;</span><span class="p">,</span>
                <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;cnn&quot;</span><span class="p">,</span>
                <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;pre_out0&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;pre_out1&quot;</span>
                <span class="p">],</span>
                <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;cnn_out0&quot;</span>
                <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;node&quot;</span><span class="p">,</span>
                <span class="nt">&quot;method_type&quot;</span><span class="p">:</span><span class="s2">&quot;${post_method}&quot;</span><span class="p">,</span>
                <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span><span class="s2">&quot;post&quot;</span><span class="p">,</span>
                <span class="nt">&quot;inputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;cnn_out0&quot;</span>
                <span class="p">],</span>
                <span class="nt">&quot;outputs&quot;</span><span class="p">:[</span>
                    <span class="s2">&quot;outputs&quot;</span>
                <span class="p">]</span>
            <span class="p">}</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type=template</span></code>代表当前文件一个模版配置，可以被当着子workflow进行交换</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template_name</span></code>为子workflow文件名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parameters</span></code>定义了一下参数名称，在后面复用该Workflow时，需要提供这些参数的值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template</span></code>定义一个子workflow内容，在该workflow定义内部，可以使用<code class="docutils literal notranslate"><span class="pre">${parameter}</span></code>进行参数引用，其他与标准workflow使用方式</p></li>
</ul>
</div>
<div class="section" id="id35">
<h4>性能统计<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<p>XStream内部提供了性能统计的工具，统计数据包括FPS和耗时。用户可以通过XStream的对外接口SetConfig打开或关闭该功能，默认该功能关闭，对外接口提供如下。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler&quot;</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>第一个参数”profiler”固定；第二个参数”on”表示打开性能统计功能，其他表示关闭性能统计功能。</p>
<p>默认使用std::cout向控制台打印输出性能统计结果，也可以调用如下接口设置Log文件，文件名称自行设置。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler_file&quot;</span><span class="p">,</span> <span class="s">&quot;./profiler.txt&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>第一个参数”profiler_file”固定；第二个参数”profiler.txt”表示性能统计数据的输出文件。</p>
<p>若程序中创建多个XStream SDK，则不同的SDK可以设置不同的配置。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xstream1</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler&quot;</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">);</span>  <span class="c1">// 设置打开profiler功能</span>
<span class="n">xstream1</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler_file&quot;</span><span class="p">,</span> <span class="s">&quot;./profiler_1.txt&quot;</span><span class="p">);</span>  <span class="c1">// 设置框架层统计数据输出文件</span>

<span class="n">xstream2</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler&quot;</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">);</span>  <span class="c1">// 设置打开profiler功能</span>
<span class="n">xstream2</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler_file&quot;</span><span class="p">,</span> <span class="s">&quot;./profiler_2.txt&quot;</span><span class="p">);</span>  <span class="c1">// 设置框架层统计数据输出文件</span>
</pre></div>
</div>
<p>Method内的统计数据默认输出至文件”PROFILER_METHOD.txt”, 用户若需要更改，可通过访问性能统计的全局单例设置智能策略内的统计数据：<code class="docutils literal notranslate"><span class="pre">Profiler::Get()-&gt;SetOutputFile(&quot;xx.txt&quot;)</span></code></p>
<p>目前XStream内支持的性能统计数据包括处理时长（Time）和帧率（FPS）两种。其中函数处理时长的默认统计最小间隔是3000微秒（即3毫秒），若函数处理时间低于3毫秒，则不计入统计范围；帧率的默认统计最小间隔是200毫秒，若统计周期小于200毫秒，则不计入统计。为了支持不同业务场景的处理耗时不同，目前支持用户对统计粒度的修改。</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">SetConfig(const</span> <span class="pre">std::string</span> <span class="pre">&amp;key,</span> <span class="pre">const</span> <span class="pre">std::string</span> <span class="pre">&amp;value)</span></code></p>
<p>key为”profiler_time_interval”, value为整型数据（单位：微秒）, 表示设置函数处理时长的最小间隔。</p>
<p>key为”profiler_fps_interval”, value为整型数据（单位：微秒）, 用于设置帧率的最小间隔。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">xstream1</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler_frame_interval&quot;</span><span class="p">,</span> <span class="s">&quot;800000&quot;</span><span class="p">);</span>   <span class="c1">// 设置记录帧率的最小间隔为800毫秒</span>
<span class="n">xstream1</span><span class="o">-&gt;</span><span class="n">SetConfig</span><span class="p">(</span><span class="s">&quot;profiler_time_interval&quot;</span><span class="p">,</span> <span class="s">&quot;1000&quot;</span><span class="p">);</span>  <span class="c1">// 设置记录函数处理时长的最小间隔为1毫秒</span>
</pre></div>
</div>
<ul class="simple">
<li><p>性能统计数据可视化</p></li>
</ul>
<p>用户打开性能统计后，若统计结果输出到文件”profiler.txt”，可以通过访问<code class="docutils literal notranslate"><span class="pre">chrome://tracing/</span></code>，通过页面的<code class="docutils literal notranslate"><span class="pre">Load</span></code>按钮将文件加载，即可看到统计数据可视化界面。以下图为例，页面上的横坐标表示”时间”；前几行(标志是字母)的纵坐标表示对应Method处理的帧率；后几行(标志是数字)的纵坐标表示不同线程”thread_id”，同时页面左下角提供了缩放、拖动等工具以便用户查看数据细节。</p>
<p><img alt="统计数据可视化" src="../../_images/profiler.png" /></p>
<p>使用缩放工具缩放坐标，可以查看数据细节，不同的函数执行时间以不同颜色标志，并标记函数处理类型，如下图：
<img alt="统计数据可视化" src="../../_images/profiler_zoom.png" /></p>
<p><strong>注意：本节中提到的FPS以及耗时的性能统计是在单线程维度上的，若用户打开多个线程，则整体的FPS需要做累加</strong>。</p>
</div>
<div class="section" id="id36">
<h4>数据流可视化工具<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<p>XStream内的数据流是通过配置json文件来生成的，框架内目前已对数据流配置是否有效进行了检查，而此工具可将配置的json文件数据流向图可视化，生成一份自定义格式的文档或图片，以直观的方式展现json文件中的数据流向。</p>
<p>工具位于<code class="docutils literal notranslate"><span class="pre">source/common/xstream/framework/tools/xstream_framework_datashow.py</span></code></p>
<p><strong>1. 准备环境</strong>：工具通过python3 + graphviz + dot实现，使用前需安装 python3（推荐python3.5.2）、graphviz库、json库</p>
<p><strong>2. 使用工具</strong>：</p>
<p>使用该文件的运行格式为：python xstream_framework_datashow.py xxx.json 效果图如下：</p>
<p><img alt="框架" src="../../_images/xstream_framework_datashow.png" /></p>
<p><strong>3. 可视化后的workflow</strong>：</p>
<ul class="simple">
<li><p>某个node的inputs得不到feed，图中体现为：绿色填充，标签中带有字段：(No-Feed)</p></li>
<li><p>全局inputs和全局outputs重名，图中体现为：红色双箭头边相连，边带有字段：same-global-inputs-outputs</p></li>
<li><p>某些node间的outputs重名，图中体现为：浅蓝色双箭头边相连，边带有字段：same-node-outputs</p></li>
</ul>
</div>
</div>
<div class="section" id="xstream-tutorials">
<h3>XStream tutorials<a class="headerlink" href="#xstream-tutorials" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="vision-type">
<h2>内置数据结构vision_type<a class="headerlink" href="#vision-type" title="永久链接至标题">¶</a></h2>
<p>vision_type是根据IOT业务需求沉淀出来的一套数据结构。这些数据结构定义在common/xstream/vision_type/include/horizon/vision_type/vision_type.hpp中。
<strong>这些数据结构定义仅做参考，客户可以定义更简单直观的数据结构</strong></p>
<div class="section" id="id37">
<h3>图像<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h3>
<p>定义了ImageFrame接口类，数据结构中包含图像的通道号、时间戳、帧号、图像编码类别等。提供接口获取图像的宽、高、stride以及图像数据。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \~Chinese @brief 基础图像帧</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ImageFrame</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ImageFrame</span><span class="p">()</span> <span class="p">{}</span>
  <span class="c1">/// \~Chinese 图片编码方式</span>
  <span class="n">HorizonVisionPixelFormat</span> <span class="n">pixel_format</span> <span class="o">=</span>
      <span class="n">HorizonVisionPixelFormat</span><span class="o">::</span><span class="n">kHorizonVisionPixelFormatNone</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">channel_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">frame_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 图像数据</span>
  <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="nf">Data</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese UV分量数据</span>
  <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="nf">DataUV</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 图片大小</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">DataSize</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese UV分量大小</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">DataUVSize</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 宽度</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">Width</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 高度</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">Height</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 长度</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">Stride</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese uv长度</span>
  <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">StrideUV</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>基于ImageFrame接口类，派生出CVImageFrame、PymImageFrame等具体数据类型，分别用于表示一帧图像数据以及一个金字塔图像数据。金字塔图像数据用得更多些，目前图像金字塔用于表示地平线芯片输出的NV12格式的图像金字塔。相关的数据结构表示如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// 图像金字塔每层图像的表示</span>
<span class="k">struct</span> <span class="n">ImageLevelInfo</span> <span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">width</span><span class="p">;</span>  <span class="c1">// 当前金字塔层图像的宽</span>
  <span class="kt">uint16_t</span> <span class="n">height</span><span class="p">;</span>  <span class="c1">// 当前金字塔层图像的高</span>
  <span class="kt">uint16_t</span> <span class="n">stride</span><span class="p">;</span>  <span class="c1">// 图像每行的stride</span>
  <span class="kt">uint64_t</span> <span class="n">y_paddr</span><span class="p">;</span>  <span class="c1">// 图像y分量的物理地址</span>
  <span class="kt">uint64_t</span> <span class="n">c_paddr</span><span class="p">;</span>  <span class="c1">// 图像uv分量的物理地址</span>
  <span class="kt">uint64_t</span> <span class="n">y_vaddr</span><span class="p">;</span>  <span class="c1">// 图像y分量的虚拟地址</span>
  <span class="kt">uint64_t</span> <span class="n">c_vaddr</span><span class="p">;</span>  <span class="c1">// 图像uv分类的虚拟地址</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">PymImageFrame</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ImageFrame</span> <span class="p">{</span>
  <span class="n">PymImageFrame</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;PymImageFrame&quot;</span><span class="p">;</span>
    <span class="n">pixel_format</span> <span class="o">=</span> <span class="n">HorizonVisionPixelFormat</span><span class="o">::</span><span class="n">kHorizonVisionPixelFormatPYM</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">ds_pym_total_layer</span><span class="p">;</span>  <span class="c1">// 下采样的总层数</span>
  <span class="kt">int</span> <span class="n">us_pym_total_layer</span><span class="p">;</span>  <span class="c1">// 上采样的总层数</span>
  <span class="n">ImageLevelInfo</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">DOWN_SCALE_MAX</span><span class="p">];</span>  <span class="c1">// 金字下采样层所有层的数据</span>
  <span class="n">ImageLevelInfo</span> <span class="n">up_scale</span><span class="p">[</span><span class="n">UP_SCALE_MAX</span><span class="p">];</span>  <span class="c1">// 金字塔上采样层所有层的数据</span>
  <span class="n">ImageLevelInfo</span> <span class="n">down_scale_main</span><span class="p">[</span><span class="n">DOWN_SCALE_MAIN_MAX</span><span class="p">];</span>  <span class="c1">// 金字塔下采样基本缩放层的数据，基本缩放层指缩放1/2、1/4、1/8、1/16这些层</span>
  <span class="n">ImageLevelInfo</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">pym_layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 需要获取金字塔那一层的数据</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">/// \~Chinese y分量数据</span>
  <span class="kt">uint64_t</span> <span class="nf">Data</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pym_layer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pym_layer</span> <span class="o">&lt;</span> <span class="n">DOWN_SCALE_MAX</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">pym_layer</span><span class="p">].</span><span class="n">y_vaddr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// \~Chinese uv分量数据</span>
  <span class="kt">uint64_t</span> <span class="nf">DataUV</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pym_layer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pym_layer</span> <span class="o">&lt;</span> <span class="n">DOWN_SCALE_MAX</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">pym_layer</span><span class="p">].</span><span class="n">c_vaddr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// \~Chinese y分量大小</span>
  <span class="kt">uint32_t</span> <span class="nf">DataSize</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Stride</span><span class="p">()</span> <span class="o">*</span> <span class="n">Height</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">uint32_t</span> <span class="nf">DataUVSize</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">StrideUV</span><span class="p">()</span> <span class="o">*</span> <span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">/// \~Chinese 宽度</span>
  <span class="kt">uint32_t</span> <span class="nf">Width</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pym_layer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pym_layer</span> <span class="o">&lt;</span> <span class="n">DOWN_SCALE_MAX</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">pym_layer</span><span class="p">].</span><span class="n">width</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// \~Chinese 高度</span>
  <span class="kt">uint32_t</span> <span class="nf">Height</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pym_layer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pym_layer</span> <span class="o">&lt;</span> <span class="n">DOWN_SCALE_MAX</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">pym_layer</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// \~Chinese 长度</span>
  <span class="kt">uint32_t</span> <span class="nf">Stride</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pym_layer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pym_layer</span> <span class="o">&lt;</span> <span class="n">DOWN_SCALE_MAX</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">down_scale</span><span class="p">[</span><span class="n">pym_layer</span><span class="p">].</span><span class="n">stride</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// \~Chinese uv长度</span>
  <span class="kt">uint32_t</span> <span class="nf">StrideUV</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Stride</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="d">
<h3>2D坐标点与坐标点集合<a class="headerlink" href="#d" title="永久链接至标题">¶</a></h3>
<p>2D坐标点集合，可以用于表示人脸/人体关键点等，其数据结构定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \~Chinese @brief 2D坐标点</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dtype</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Point_</span> <span class="p">{</span>
  <span class="kr">inline</span> <span class="n">Point_</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kr">inline</span> <span class="n">Point_</span><span class="p">(</span><span class="n">Dtype</span> <span class="n">x_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">y_</span><span class="p">,</span> <span class="kt">float</span> <span class="n">score_</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x_</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y_</span><span class="p">),</span> <span class="n">score</span><span class="p">(</span><span class="n">score_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Dtype</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dtype</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * \~Chinese @brief 2D坐标点集合，可用于存储关键点等结果</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">Points</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 置信度</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h3>矩形检测框<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<p>矩形检测框可用于表示目标检测框。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \~Chinese @brief 检测框</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dtype</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">BBox_</span> <span class="p">{</span>
  <span class="kr">inline</span> <span class="n">BBox_</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kr">inline</span> <span class="n">BBox_</span><span class="p">(</span><span class="n">Dtype</span> <span class="n">x1_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">y1_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">x2_</span><span class="p">,</span> <span class="n">Dtype</span> <span class="n">y2_</span><span class="p">,</span> <span class="kt">float</span> <span class="n">score_</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">,</span>
               <span class="kt">int32_t</span> <span class="n">id_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">category_name_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x1_</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y1_</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x2_</span><span class="p">;</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y2_</span><span class="p">;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">id_</span><span class="p">;</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">score_</span><span class="p">;</span>
    <span class="n">category_name</span> <span class="o">=</span> <span class="n">category_name_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">Width</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">Height</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">CenterX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">Dtype</span> <span class="n">CenterY</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">Dtype</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 左上角横坐标</span>
  <span class="n">Dtype</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 左上角纵坐标</span>
  <span class="n">Dtype</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 右下角横坐标</span>
  <span class="n">Dtype</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 右下角纵坐标</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="c1">// 检测框置信度</span>
  <span class="kt">int32_t</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 目标的ID</span>
  <span class="kt">float</span> <span class="n">rotation_angle</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="c1">// 检测框沿中央点逆时针旋转角度</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">category_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>   <span class="c1">// 目标类别，比如vehicle、face</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">BBox_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">BBox</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h3>单精度浮点数组<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>浮点数组可以用于存储特征值等。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \~Chinese @brief 单精度浮点数组，可用于存储特征值、质量结果等</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">FloatArray</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 置信度</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">FloatArray</span> <span class="n">Feature</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id40">
<h3>分割<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Segmentation</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>  <span class="c1">// 分割的结果，可以将整形保持至float数组中</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">pixel_score</span><span class="p">;</span>  <span class="c1">// 每个像素的分类得分</span>
  <span class="kt">int32_t</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 分割输出的宽</span>
  <span class="kt">int32_t</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 分割输出的高</span>
  <span class="c1">/// \~Chinese  置信度</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h3>3D姿态<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<p>用于描述pitch、yaw、roll的角度。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Pose3D</span> <span class="p">{</span>
  <span class="c1">/// \~Chinese 俯仰角度</span>
  <span class="kt">float</span> <span class="n">pitch</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 左右摇头角度</span>
  <span class="kt">float</span> <span class="n">yaw</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 侧头角度</span>
  <span class="kt">float</span> <span class="n">roll</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 置信度</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h3>通用属性类<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<p>用于描述分类类属性结果。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">DType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Attribute</span> <span class="p">{</span>
  <span class="n">DType</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// \~Chinese 置信度</span>
  <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">Attribute</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">Gender</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Attribute</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">Glass</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Attribute</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">Quality</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Attribute</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">AntiSpoofing</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Attribute</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">BreathingMask</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h3>年龄<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h3>
<p>地平线模型对应的年龄性别表示方式，不具有通用性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Age</span> <span class="p">{</span>
  <span class="o">///</span> \<span class="o">~</span><span class="n">Chinese</span> <span class="n">年龄分类</span>
  <span class="n">int32_t</span> <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">///</span> \<span class="o">~</span><span class="n">Chinese</span> <span class="n">年龄段下限</span>
  <span class="n">int32_t</span> <span class="nb">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">///</span> \<span class="o">~</span><span class="n">Chinese</span> <span class="n">年龄段上限</span>
  <span class="n">int32_t</span> <span class="nb">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">///</span> \<span class="o">~</span><span class="n">Chinese</span> <span class="n">置信度</span>
  <span class="nb">float</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h3>抓拍信息<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h3>
<p>用于表示地平线抓拍策略的输出，不具有通用性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>template &lt;typename DType&gt;
struct SnapshotInfo {
  SnapshotInfo();
  /**
   * \~Chinese @brief 抓拍图坐标转换接口,抓拍图里面包含目标检测框，将目标检测框的坐标信息从原图大小映射到抓拍图的大小
   *
   * \~Chinese @param in [in] 相对于原始帧的一组坐标
   * \~Chinese @return Points 相对于抓拍图的一组坐标
   */
  virtual Points PointsToSnap(const Points &amp;in);

  /// \~Chinese 抓拍类型
  int32_t type;
  /// track id
  int32_t track_id;
  /// \~Chinese 优选参考值
  float select_value;
  /// \~Chinese 抓拍发生时原始帧数据，可以为空
  std::shared_ptr&lt;ImageFrame&gt; origin_image_frame;
  /// \~Chinese 抓拍图数据
  std::shared_ptr&lt;ImageFrame&gt; snap;
  /// \~Chinese 用户数据数组
  std::vector&lt;DType&gt; userdata;
};
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h3>XStream-Framework使用这些数据结构<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h3>
<p>定义的这些数据结构不是继承自XStream-Framework中定义的BaseData基类，故不能直接在XStream-Framework框架中使用，需要借助XStream-Framework提供的包装类模块进行封装：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dtype</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">XStreamData</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseData</span> <span class="p">{</span>
  <span class="n">Dtype</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">XStreamData</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="n">XStreamData</span><span class="p">(</span><span class="k">const</span> <span class="n">Dtype</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">XStreamData</span><span class="o">&lt;</span><span class="n">BBox</span><span class="o">&gt;</span> <span class="n">box</span><span class="p">;</span>  <span class="c1">// 则XStreamData&lt;BBox&gt;继承自BaseData，里面包含一个数据成员value，类型为BBox。</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id46">
<h2>内置Method<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<p>本节主要介绍XStream内置的算法Method和策略Method，以及解释如何基于这些Method进行业务开发。</p>
<p>智能业务中Method类型通常可以分为两类：</p>
<ol class="simple">
<li><p>算法Method：该类Method主要完成load模型、前处理并送给BPU完成预测、获取预测结果、完成结果解析等。</p></li>
<li><p>策略Method:　该类Method无算法模型相关处理，是业务相关的策略模型，如过滤策略Method、融合策略Method、优选策略Method等。</p></li>
</ol>
<p>目前XStream中将一些常见Method沉淀，其中算法Method包括：FasterRCNNMethod、CNNMethod、PredictMethod、PostProcessMethod，策略Method包括MotMethod。XStream中已沉淀的这些Method只为用户提供参考，在提供的参考样例代码中会用到其中的Method。基于XStream框架开发时，如果不想使用内置Method，可以根据自己的需求(例如，不同的模型输入预处理、不同的模型和模型输出后处理等)，参考已有的Method，独立开发自定义的Method。</p>
<div class="section" id="fasterrcnnmethod">
<h3>FasterRCNNMethod<a class="headerlink" href="#fasterrcnnmethod" title="永久链接至标题">¶</a></h3>
<p>FasterRCNNMethod主要是对fasterrcnn检测算法模型的集成。通常，FasterRCNNMethod的输入是类型为PymImageFrame或CVImageFrame的图像，具体可以参考<a class="reference external" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84vision_type">内置数据结构vision_type</a>。预处理将图像数据resize成模型输入大小并做格式转换，模型预测通过调用BPU相关接口实现，后处理主要是对多种输出的解析，如检测框、关键点、分割等。</p>
<div class="section" id="id47">
<h4>配置文件<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h4>
<p>使用FasterRCNNMethod时，首先要清楚模型每层的输出是什么，更改对应的配置文件进行适配。配置中的主要参数如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>net_info</td>
<td>和模型相关的信息</td>
</tr>
<tr>
<td>model_name</td>
<td>编译出的hbm文件中模型的名字</td>
</tr>
<tr>
<td>model_version</td>
<td>模型的版本号，GetVersion接口返回的就是这个值</td>
</tr>
<tr>
<td>pyramid_layer</td>
<td>模型用到的金字塔图像数据的第几层</td>
</tr>
<tr>
<td>method_outs</td>
<td>method的实际输出，与workflow中Node的输出对应，可以配置为该模型输出能力的子集</td>
</tr>
<tr>
<td>bpu_config_path</td>
<td>bpu_predict配置的路径</td>
</tr>
<tr>
<td>model_file_path</td>
<td>模型文件的路径</td>
</tr>
<tr>
<td>face_pv_thr</td>
<td>人脸的置信度阈值，没达到置信度阈值的face_box及关联的人脸lmk和人脸pose一并不输出，默认阈值为0</td>
</tr>
<tr>
<td>model_input_width</td>
<td>模型输入的宽</td>
</tr>
<tr>
<td>model_input_height</td>
<td>模型输入的高</td>
</tr>
<tr>
<td>model_out_sequence</td>
<td>模型输出各分支的信息，我们需要根据model_out_sequence来进行模型结果的后处理</td>
</tr>
</tbody>
</table><p>对于”model_out_sequence”,其内部个参数含义如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>输出的名字</td>
</tr>
<tr>
<td>type</td>
<td>输出的类型</td>
</tr>
<tr>
<td>box_name</td>
<td>依赖的box的名字</td>
</tr>
</tbody>
</table><p>FasterRCNNMethod配置文件示例：</p>
<p>示例中检测模型输入数据大小是540x960，输出共5层，分别是人体框、人头框、人脸框、人体骨骼点和人体分割。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;net_info&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;model_name&quot;</span><span class="p">:</span> <span class="s2">&quot;personMultitask&quot;</span><span class="p">,</span>
    <span class="nt">&quot;model_version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;model_out_sequence&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;body_box&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;bbox&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;head_box&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;bbox&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;face_box&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;bbox&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;kps&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;kps&quot;</span><span class="p">,</span>
        <span class="nt">&quot;box_name&quot;</span><span class="p">:</span> <span class="s2">&quot;body_box&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;mask&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;mask&quot;</span><span class="p">,</span>
        <span class="nt">&quot;box_name&quot;</span><span class="p">:</span> <span class="s2">&quot;body_box&quot;</span>
      <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">&quot;model_input_width&quot;</span><span class="p">:</span> <span class="mi">960</span><span class="p">,</span>
    <span class="nt">&quot;model_input_height&quot;</span><span class="p">:</span> <span class="mi">540</span><span class="p">,</span>
    <span class="nt">&quot;pyramid_layer&quot;</span><span class="p">:</span> <span class="mi">4</span>
  <span class="p">},</span>
  <span class="nt">&quot;method_outs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;face_box&quot;</span><span class="p">,</span> <span class="s2">&quot;head_box&quot;</span><span class="p">,</span> <span class="s2">&quot;body_box&quot;</span><span class="p">,</span><span class="s2">&quot;kps&quot;</span><span class="p">,</span><span class="s2">&quot;mask&quot;</span><span class="p">],</span>
  <span class="nt">&quot;bpu_config_path&quot;</span><span class="p">:</span> <span class="s2">&quot;../configs/bpu_config.json&quot;</span><span class="p">,</span>
  <span class="nt">&quot;model_file_path&quot;</span><span class="p">:</span> <span class="s2">&quot;../models/IPCModel.hbm&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cnnmethod">
<h3>CNNMethod<a class="headerlink" href="#cnnmethod" title="永久链接至标题">¶</a></h3>
<p>CNNMethod主要是对检测框的属性进行预测，比如年龄性别、人脸识别、手势识别、摔倒检测、车辆属性等。</p>
<div class="section" id="id48">
<h4>配置文件<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h4>
<p>同理，使用CNNMethod时需要清楚用到的模型的输入数据类型，以及后处理的类型。</p>
<p>目前支持的输入数据类型包括rect、lmk、img、plate_num_img、lmk_seq、vid，其中rect与img都表示矩形框数据，区别在于rect输入需要对应模型的编译选项是resizer、img输入对应模型的编译选项是pyramid；lmk在矩形框数据基础上包括了人脸关键点；plate_num_img用于车牌框数据，与img的区别在于检测框的预处理；lmk_seq表示关键点序列，用于摔倒检测与手势识别；vid表示raw data，目前用于表示体感游戏中人体骨骼特征。</p>
<p>后处理类型包括：face_feature、antispoofing、face_quality、binary_classify、lmk_pose、age_gender、vehicle_type、vehicle_color、plate_num、classify、act_det、back_bone、vid、common_lmk。</p>
<p>face_feature表示人脸特征；</p>
<p>antispoofing表示活体识别；</p>
<p>face_quality表示人脸质量；</p>
<p>binary_classify表示二元分类；</p>
<p>lmk_pose表示人脸关键点以及人脸3d位置；</p>
<p>age_gender表示年龄性别；</p>
<p>vehicle_type表示车辆类型；</p>
<p>vehicle_color表示车辆颜色；</p>
<p>plate_num表示车牌号字符串输出；</p>
<p>classify表示车牌号整型输出；</p>
<p>act_det表示行为识别，目前支持摔倒检测和手势识别；</p>
<p>back_bone表示人体骨骼特征，目前用于体感游戏；</p>
<p>common_lmk表示关键点检测，目前用于手关键点检测。</p>
<p>配置中主要参数如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>配置名</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>model_name</td>
<td>编译模型时指定的模型名字</td>
<td></td>
</tr>
<tr>
<td>model_version</td>
<td>模型版本号</td>
<td></td>
</tr>
<tr>
<td>model_file_path</td>
<td>模型文件地址</td>
<td></td>
</tr>
<tr>
<td>bpu_config_path</td>
<td>bpu的配置文件地址</td>
<td></td>
</tr>
<tr>
<td>in_msg_type</td>
<td>模型的处理方式（resizer或者pyramid或者ddr）</td>
<td>rect/img(resizer/pyramid)/lmk_seq</td>
</tr>
<tr>
<td>norm_method</td>
<td>pyramid方式必填</td>
<td>norm_by_width_length<br />norm_by_width_ratio<br />norm_by_height_rario<br />norm_by_lside_ratio<br />norm_by_height_length<br />norm_by_lside_length<br />norm_by_lside_square<br />norm_by_diagonal_square<br />norm_by_nothing</td>
</tr>
<tr>
<td>filter_method</td>
<td>pyramid方式必填</td>
<td>out_of_range<br />no_filter</td>
</tr>
<tr>
<td>expand_scale</td>
<td>pyramid方式必填</td>
<td>外扩系数</td>
</tr>
<tr>
<td>post_fn</td>
<td>后处理方式</td>
<td>face_feature<br />antispoofing<br />lmk_pose<br />age_gender<br />face_quality<br />act_det</td>
</tr>
<tr>
<td>threshold</td>
<td>阈值</td>
<td></td>
</tr>
<tr>
<td>input_shift</td>
<td>输入转浮点时参数</td>
<td></td>
</tr>
<tr>
<td>seq_len</td>
<td>输入序列长度</td>
<td></td>
</tr>
<tr>
<td>stride</td>
<td>序列步长</td>
<td></td>
</tr>
<tr>
<td>max_gap</td>
<td>步长允许误差范围</td>
<td></td>
</tr>
<tr>
<td>buf_len</td>
<td>缓存buffer长度</td>
<td></td>
</tr>
<tr>
<td>norm_kps_conf</td>
<td>是否强制进行关键点置信度归一化</td>
<td></td>
</tr>
<tr>
<td>kps_norm_scale</td>
<td>关键点置信度归一化参数</td>
<td></td>
</tr>
<tr>
<td>merge_groups</td>
<td>类别融合</td>
<td>字符串，需要保证格式为"[group1_idx1,group1_idx2];[group2_idx1,group_idx2]"</td>
</tr>
<tr>
<td>target_group_idx</td>
<td>目标类别index</td>
<td></td>
</tr>
<tr>
<td>max_handle_num</td>
<td>最大处理数量</td>
<td>负数表示无限制</td>
</tr>
<tr>
<td>output_size</td>
<td>输出槽的个数</td>
<td></td>
</tr>
</tbody>
</table><p>配置文件示例：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
  &quot;model_name&quot;: &quot;faceAntiSpfRGB&quot;,
  &quot;model_version&quot;: &quot;x2.1.0.11&quot;,
  &quot;model_file_path&quot;: &quot;../models/PanelBoard.hbm&quot;,
  &quot;bpu_config_path&quot;: &quot;../bpu_config/bpu_config.json&quot;,
  &quot;in_msg_type&quot;: &quot;img&quot;,     # 输入类型，决定前处理方式和使用的bpu-predict接口
  &quot;norm_method&quot;: &quot;norm_by_lside_square&quot;,    # normalize方法，需要和算法对齐
  &quot;filter_method&quot;: &quot;no_filter&quot;,
  &quot;expand_scale&quot;: 1.5,
  &quot;post_fn&quot;: &quot;antispoofing&quot;,  # 后处理函数
  &quot;threshold&quot;: 0.1,
  &quot;max_handle_num&quot;: -1,
  &quot;output_size&quot;: 2
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="predictmethod-postprocessmethod">
<h3>PredictMethod&amp;&amp;PostProcessMethod<a class="headerlink" href="#predictmethod-postprocessmethod" title="永久链接至标题">¶</a></h3>
<p>前面介绍的FasterRCNNMethod和CNNMethod中，两者的核心处理函数DoProcess中都是按照数据预处理、预测、后处理的步骤来进行。同一线程中，只有前一帧数据按照整个pipeline完成后，后一帧数据才能够开始处理。因此在使用FasterRCNNMethod和CNNMethod时，要通过设置多个thread_list来提升bpu使用率，并且这种方法也无法做到性能最优。因此，提出了PredictMethod和PostProcessMethod。</p>
<p>顾名思义，PredictMethod功能是向BPU输入数据进行预测，PostProcessMethod功能是将BPU的输出进行后处理。PredictMethod中的预测过程与FasterRCNNMethod、CNNMethod的最大差异是调用了BPU的异步预测接口，而PostProcessMethod等待预测完成后进行后处理。<strong>注意：PredictMethod和PostProcessMethod必须要配合使用</strong>，也就是说搭建的workflow中，PredictMethod节点的输出数据流驱动PostProcessMethod节点。</p>
<p>workflow示例：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;image&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;image&quot;</span><span class="p">,</span>
      <span class="s2">&quot;parking_box&quot;</span>
    <span class="p">],</span>
    <span class="nt">&quot;workflow&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;PredictMethod&quot;</span><span class="p">,</span>
        <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;predict&quot;</span><span class="p">,</span>
        <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="s2">&quot;image&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="s2">&quot;run_data&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;predict_apa_detection.json&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;thread_count&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nt">&quot;method_type&quot;</span><span class="p">:</span> <span class="s2">&quot;PostProcessMethod&quot;</span><span class="p">,</span>
        <span class="nt">&quot;unique_name&quot;</span><span class="p">:</span> <span class="s2">&quot;post&quot;</span><span class="p">,</span>
        <span class="nt">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="s2">&quot;run_data&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;outputs&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="s2">&quot;parking_box&quot;</span>
        <span class="p">],</span>
        <span class="nt">&quot;method_config_file&quot;</span><span class="p">:</span> <span class="s2">&quot;postprocess_apa_detection.json&quot;</span>
      <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="predictmethod">
<h4>PredictMethod<a class="headerlink" href="#predictmethod" title="永久链接至标题">¶</a></h4>
<p>PredictMethod可以进行各种模型的预测，包括检测任务和属性分类任务等，但实际应用中不同的模型输入类型或数目不一致，需要根据模型扩展不同预处理。目前PredictMethod支持了检测任务的预测。</p>
<p>配置文件示例：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;predict_type&quot;</span><span class="p">:</span> <span class="s2">&quot;detect&quot;</span><span class="p">,</span>
    <span class="nt">&quot;pyramid_layer&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&quot;model_file_path&quot;</span><span class="p">:</span> <span class="s2">&quot;../../models/detection.hbm&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配置文件说明：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>predict_type</td>
<td>预测类型</td>
<td>detect<br />classify(暂不可用)</td>
</tr>
<tr>
<td>pyramid_layer</td>
<td>模型用到的金字塔图像数据的第几层</td>
<td></td>
</tr>
<tr>
<td>model_file_path</td>
<td>模型路径</td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="section" id="postprocessmethod">
<h4>PostProcessMethod<a class="headerlink" href="#postprocessmethod" title="永久链接至标题">¶</a></h4>
<p>PostProcessMethod的主要任务是获取预测结果，并根据模型进行后处理。因此需要对不同的模型设置不同的配置文件。</p>
<p>配置文件示例：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;post_type&quot;</span><span class="p">:</span> <span class="s2">&quot;detect&quot;</span><span class="p">,</span>
    <span class="nt">&quot;net_info&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;model_out_sequence&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;parking_box&quot;</span><span class="p">,</span>
          <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;apabbox&quot;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="nt">&quot;method_outs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;parking_box&quot;</span><span class="p">],</span>
    <span class="nt">&quot;iou_threshold&quot;</span><span class="p">:</span> <span class="mf">0.3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配置文件说明：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>post_type</td>
<td>预测类型</td>
<td>detect<br />classify(暂不可用)</td>
</tr>
<tr>
<td>net_info</td>
<td>模型用到的金字塔图像数据的第几层</td>
<td></td>
</tr>
<tr>
<td>model_out_sequence</td>
<td>模型路径</td>
<td></td>
</tr>
<tr>
<td>method_outs</td>
<td>method的实际输出，与workflow中Node的输出对应，可以配置为该模型输出能力的子集</td>
<td></td>
</tr>
<tr>
<td>iou_threshold</td>
<td>检测窗口IoU阈值</td>
<td>当两个检测框的IoU大于该阈值时取置信度较高的检测框结果</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="motmethod">
<h3>MotMethod<a class="headerlink" href="#motmethod" title="永久链接至标题">¶</a></h3>
<p>MotMethod属于策略Method，用于多目标跟踪，实现检测框的跟踪和ID分配功能。</p>
<div class="section" id="id49">
<h4>输入<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Slot</th>
<th align="center">内容</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">XStreamBBox_list</td>
<td align="center">必要项</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id50">
<h4>输出<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Slot</th>
<th align="center">内容</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">XStreamBBox_list</td>
<td align="center">带track_id</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">XStreamUint32_List</td>
<td align="center">disappeared_track_id_list</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id51">
<h4>配置文件<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">字段</th>
<th>描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">tracker_type</td>
<td>MOT工作模式，目前仅支持IOU based MOT</td>
<td align="center">IOU</td>
</tr>
<tr>
<td align="center">device</td>
<td>设备名称，若设置为X1，最大track_id为255，用以比对一致性</td>
<td align="center">X2</td>
</tr>
<tr>
<td align="center">update_no_target_predict</td>
<td>无检测框输入更新状态机track预测框，设置为true对主体连续运动且有遮挡的场景效果好，设置为false对主体不移动且有遮挡的场景效果好</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">support_hungarian</td>
<td>匈牙利匹配开关，打开匈牙利匹配id召回多，准确率下降；关闭则id召回少，准确率提升</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">need_check_merge</td>
<td>每组输入框IOU大于一定阈值做融合，该操作会影响输出数量，检测框融合多在检测模块完成，一般情况置为false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">original_bbox</td>
<td>是否使用卡尔曼滤波器预测框，true为不使用，输出原始框坐标</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">max_track_target_num</td>
<td>状态机保存最大track数</td>
<td align="center">512</td>
</tr>
<tr>
<td align="center">max_det_target_num</td>
<td>输入框最大计算数</td>
<td align="center">512</td>
</tr>
<tr>
<td align="center">vanish_frame_count</td>
<td>消失帧数</td>
<td align="center">30</td>
</tr>
</tbody>
</table></div>
</div>
</div>
<div class="section" id="imagetools">
<h2>图像处理imagetools<a class="headerlink" href="#imagetools" title="永久链接至标题">¶</a></h2>
<div class="section" id="id52">
<h3>功能介绍<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h3>
<p>imagetools是xstream自带的使用软件实现的常用图像处理函数。具体包括：图像解码、图像格式转换、图像缩放、抠图、padding、镜像翻转、中心旋转等功能。开发者可根据自己需要，自行选择使用或者不使用xstream自带的图像处理函数。</p>
<p>imagetools的具体使用方法可以参考source/common/xstream/imagetools/example目录下样例代码，和source/common/xstream/imagetools/test目录下单元测试代码。</p>
</div>
<div class="section" id="id53">
<h3>实现方式<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h3>
<p>imagetools对直接使用的开发者提供一套简洁清晰的接口，imagetools内部会调用libturbojpeg、libyuv、opencv等库的接口，通过软件来实现对图像进行各种处理。</p>
</div>
<div class="section" id="id54">
<h3>接口描述<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">* @brief 分配图像内存区域</span>
<span class="cm">* @param image_size 图像区域的大小， 要求image_size &gt; 0</span>
<span class="cm">* @param output_image 分配的图像区域，要求output_image != NULl</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamAllocImage</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">image_size</span><span class="p">,</span>
<span class="kt">uint8_t</span><span class="o">**</span> <span class="n">output_image</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 释放图像接口返回的内存</span>
<span class="cm">* @param input: 指针，由HobotXStreamDecodeImage/HobotXStreamConvertImage</span>
<span class="cm">* /HobotXStreamResizeImage</span>
<span class="cm">* /HobotXStreamCropImage</span>
<span class="cm">* /HobotXStreamPadImage等接口返回的输出数据的地址。</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamFreeImage</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">input</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 解码图片至dst_fmt格式。接口内部分配输出的内存空间\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.</span>
<span class="cm">* 注意：若原图的宽与高存在奇数，且要求解码后的图像是YUV420系列，则解码会失败!</span>
<span class="cm">* @param input: 输入图片二进制数据，支持jpg/png/bmp</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param dst_fmt： 解码后的图像格式</span>
<span class="cm">* @param output: 解码后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 解码后的图片二进制数据长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamDecodeImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">dst_fmt</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 图像转码。接口内部分配输出的内存空间\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像分辨率不变</span>
<span class="cm">* 注意：若转换成YUV420系列，则要求图片分辨率的高与宽均为偶数，否则转码失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param input_fmt: 输入图像的格式</span>
<span class="cm">* @param output_fmt: 转码后图像的格式</span>
<span class="cm">* @param output: 转码后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 转码后的图片二进制数据长度</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamConvertImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">input_fmt</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">output_fmt</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 对YUV420图像进行图像格式转换（y、u、v存储空间可能不连续的情况）\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像分辨率不变</span>
<span class="cm">* @param input_yuv_data: 输入图片二进制数据，[0]固定为y分量的地址，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv的地址，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的地址，[2]固定为v的地址</span>
<span class="cm">* @param input_yuv_size: 输入图片二进制数据长度，[0]固定为y分量的长度，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv分量的长度，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的长度，[2]固定为v的长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param input_fmt: 输入图像的格式</span>
<span class="cm">* @param output_fmt: 转码后图像的格式</span>
<span class="cm">* @param output: 转码后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 转码后的图片二进制数据长度</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">*/</span>

<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamConvertYuvImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input_yuv_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_yuv_size</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">input_fmt</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">output_fmt</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 根据目标尺寸缩放图像\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求缩放前后图像分辨率的高与宽均为偶数，</span>
<span class="cm">* 否则缩放失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param fix_aspect_ratio: 1为保持宽高比。0为直接缩放</span>
<span class="cm">* 当保持宽高比时，会在图像右侧与下方填充黑色。</span>
<span class="cm">* @param dst_width: 目标图片的宽</span>
<span class="cm">* @param dst_height: 目标图片的高</span>
<span class="cm">* @param output: 缩放后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 缩放后的图片二进制数据长度</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @param resize_info: 缩放参数</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamResizeImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">fix_aspect_ratio</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">dst_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">dst_height</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">,</span>
<span class="k">struct</span> <span class="n">HobotXStreamImageToolsResizeInfo</span> <span class="o">*</span><span class="n">resize_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 根据缩放因子缩放图像\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求缩放前后图像分辨率的高与宽均为偶数，</span>
<span class="cm">* 否则缩放失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param fix_aspect_ratio: 1为保持宽高比。0为直接缩放</span>
<span class="cm">* 当保持宽高比时，会在图像右侧与下方填充黑色。</span>
<span class="cm">* @param width_ratio: 宽的缩放因子, width_ratio = dst_width / input_width</span>
<span class="cm">* @param height_ratio:</span>
<span class="cm">* @param output: 缩放后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 缩放后的图片二进制数据长度</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @param resize_info: 缩放参数</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamResizeImageByRatio</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">fix_aspect_ratio</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">width_ratio</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">height_ratio</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">,</span>
<span class="k">struct</span> <span class="n">HobotXStreamImageToolsResizeInfo</span> <span class="o">*</span><span class="n">resize_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 抠图\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求抠图区域的宽与高均为偶数，</span>
<span class="cm">* 否则抠图失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param input_width: 输入图片的宽</span>
<span class="cm">* @param input_height: 输入图片的高</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param top_left_x: 要求&gt;= 0</span>
<span class="cm">* @param top_left_y: 要求&gt;= 0</span>
<span class="cm">* @param bottom_right_x: 要求&gt;= 0</span>
<span class="cm">* @param bottom_right_y: 要求&gt;= 0</span>
<span class="cm">* @param output: 抠图的图片二进制数据地址</span>
<span class="cm">* @param output_size: 抠图的图片二进制数据长度</span>
<span class="cm">* @param output_width: 抠图的宽</span>
<span class="cm">* @param output_height: 抠图的高</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamCropImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_y</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_y</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm">* @brief 抠图\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求抠图区域的宽与高均为偶数，</span>
<span class="cm">* 否则抠图失败</span>
<span class="cm">* @param input_yuv_data: 输入图片二进制数据，[0]固定为y分量的地址，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv的地址，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的地址，[2]固定为v的地址</span>
<span class="cm">* @param input_yuv_size: 输入图片二进制数据长度，[0]固定为y分量的长度，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv分量的长度，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的长度，[2]固定为v的长度</span>
<span class="cm">* @param input_width: 输入图片的宽</span>
<span class="cm">* @param input_height: 输入图片的高</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param top_left_x: 要求&gt;= 0</span>
<span class="cm">* @param top_left_y: 要求&gt;= 0</span>
<span class="cm">* @param bottom_right_x: 要求&gt;= 0</span>
<span class="cm">* @param bottom_right_y: 要求&gt;= 0</span>
<span class="cm">* @param output: 抠图的图片二进制数据地址</span>
<span class="cm">* @param output_size: 抠图的图片二进制数据长度</span>
<span class="cm">* @param output_width: 抠图的宽</span>
<span class="cm">* @param output_height: 抠图的高</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamCropYUVImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input_yuv_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_yuv_size</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_y</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_y</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 抠图\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 若抠图区域超过图像边界，则超过区域补黑色</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求抠图区域的宽与高均为偶数，且yuv存储空间需连续</span>
<span class="cm">* 否则抠图失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param input_width: 输入图片的宽</span>
<span class="cm">* @param input_height: 输入图片的高</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param top_left_x:</span>
<span class="cm">* @param top_left_y:</span>
<span class="cm">* @param bottom_right_x: 要求&gt; top_left_x</span>
<span class="cm">* @param bottom_right_y: 要求&gt; top_left_y</span>
<span class="cm">* @param output: 抠图的图片二进制数据地址</span>
<span class="cm">* @param output_size: 抠图的图片二进制数据长度</span>
<span class="cm">* @param output_width: 抠图的宽</span>
<span class="cm">* @param output_height: 抠图的高</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamCropImageWithPaddingBlack</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_y</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_y</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 对YUV420图像抠图（y、u、v存储空间可能不连续的情况）\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 若抠图区域超过图像边界，则超过区域补黑色</span>
<span class="cm">* 要求抠图区域的宽与高均为偶数，否则抠图失败</span>
<span class="cm">* @param input_yuv_data: 输入图片二进制数据，[0]固定为y分量的地址，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv的地址，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的地址，[2]固定为v的地址</span>
<span class="cm">* @param input_yuv_size: 输入图片二进制数据长度，[0]固定为y分量的长度，</span>
<span class="cm">* 对于nv12/nv21，[1]为uv分量的长度，[2]无效</span>
<span class="cm">* 对于i420，[1]固定为u的长度，[2]固定为v的长度</span>
<span class="cm">* @param input_width: 输入图片的宽</span>
<span class="cm">* @param input_height: 输入图片的高</span>
<span class="cm">* @param input_first_stride: y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param top_left_x:</span>
<span class="cm">* @param top_left_y:</span>
<span class="cm">* @param bottom_right_x: 要求&gt; top_left_x</span>
<span class="cm">* @param bottom_right_y: 要求&gt; top_left_y</span>
<span class="cm">* @param output: 抠图的图片二进制数据地址</span>
<span class="cm">* @param output_size: 抠图的图片二进制数据长度</span>
<span class="cm">* @param output_width: 抠图的宽</span>
<span class="cm">* @param output_height: 抠图的高</span>
<span class="cm">* @param output_first_stride: y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamCropYuvImageWithPaddingBlack</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input_yuv_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_yuv_size</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_y</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_y</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 对vision_type中c++版本的ImageFrame进行抠图</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 若抠图区域超过图像边界，则超过区域补黑色</span>
<span class="cm">* 要求抠图区域的宽与高均为偶数，否则抠图失败</span>
<span class="cm">* @param input: hobot::vision::ImageFrame</span>
<span class="cm">* @param top_left_x:</span>
<span class="cm">* @param top_left_y:</span>
<span class="cm">* @param bottom_right_x: 要求&gt; top_left_x</span>
<span class="cm">* @param bottom_right_y: 要求&gt; top_left_y</span>
<span class="cm">* @param output: 抠图的图片二进制数据地址</span>
<span class="cm">* @param output_size: 抠图的图片二进制数据长度</span>
<span class="cm">* @param output_width: 抠图的宽</span>
<span class="cm">* @param output_height: 抠图的高</span>
<span class="cm">* @param output_first_stride:</span>
<span class="cm">* @param output_second_stride:</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamCropImageFrameWithPaddingBlack</span><span class="p">(</span>\
<span class="kt">void</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">top_left_y</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_x</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">bottom_right_y</span><span class="p">,</span>
<span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="o">*</span><span class="n">output_format</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 图像四周填充元素，会导致图像分辨率变大。\</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* 注意：若图像格式为YUV420系列，则要求原图的宽、高、padding_left_width、</span>
<span class="cm">* padding_right_width、padding_top_height、padding_bottom_height</span>
<span class="cm">* 均为偶数或者0，否则paddiing失败</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param input_width: 输入图片的宽</span>
<span class="cm">* @param input_height: 输入图片的高</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param padding_left_width: 要求 &gt;= 0</span>
<span class="cm">* @param padding_right_width: 要求 &gt;= 0</span>
<span class="cm">* @param padding_top_height: 要求 &gt;= 0</span>
<span class="cm">* @param padding_bottom_height: 要求 &gt;= 0</span>
<span class="cm">* @param padding_value: 填充的像素值,长度必须为3</span>
<span class="cm">* RGB/BGR格式，则padding_value统一为[r, g, b]</span>
<span class="cm">* GRay格式，则padding_value = [gray, xx, xx]</span>
<span class="cm">* I420/NV12/NV21，则padding_value统一为[y, u, v]</span>
<span class="cm">* @param output: padding后图片二进制数据地址</span>
<span class="cm">* @param output_size: padding后的图片二进制数据长度</span>
<span class="cm">* @param output_width: padding后的图片的宽</span>
<span class="cm">* @param output_height: padding后的图片的高</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamPadImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">padding_left_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">padding_right_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">padding_top_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">padding_bottom_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">padding_value</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm">* @brief 对图像顺时针进行90/180/270度的旋转</span>
<span class="cm">* 由调用者调用HobotXStreamFreeImage接口释放.图像格式不变</span>
<span class="cm">* @param input: 输入图片二进制数据</span>
<span class="cm">* @param input_size: 输入图片二进制数据长度</span>
<span class="cm">* @param width: 图像宽度</span>
<span class="cm">* @param height: 图像高度</span>
<span class="cm">* @param input_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param input_second_stride: uv的stride</span>
<span class="cm">* @param format: 图像的格式</span>
<span class="cm">* @param degree: 图像旋转角度：90 180 270</span>
<span class="cm">* @param output: 缩放后的图片二进制数据地址</span>
<span class="cm">* @param output_size: 缩放后的图片二进制数据长度</span>
<span class="cm">* @param output_width: 目标图片的宽</span>
<span class="cm">* @param output_height: 目标图片的高</span>
<span class="cm">* @param output_first_stride: rgb/bgr/gray/y的stride</span>
<span class="cm">* @param output_second_stride: uv的stride</span>
<span class="cm">* @param resize_info: 缩放参数</span>
<span class="cm">* @return: 成功返回0，失败返回-1</span>
<span class="cm">*/</span>
<span class="n">XSTREAM_API</span> <span class="kt">int</span> <span class="nf">HobotXStreamRotateImage</span><span class="p">(</span>\
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_width</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_height</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_first_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">input_second_stride</span><span class="p">,</span>
<span class="k">const</span> <span class="k">enum</span> <span class="n">HobotXStreamImageToolsPixelFormat</span> <span class="n">format</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">degree</span><span class="p">,</span>
<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">output</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_size</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_width</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_height</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_first_stride</span><span class="p">,</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">output_second_stride</span><span class="p">);</span>

<span class="cp">#endif </span><span class="c1">// INCLUDE_HOBOTXSTREAM_IMAGE_TOOLS_H_</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Horizon Robotics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>