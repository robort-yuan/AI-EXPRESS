

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>NumPy &mdash; AI Express用户手册 2.7.0 文档</title>
  

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
        <script src="../../../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home" alt="Documentation Home"> AI Express用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/quick_start.html">快速上手</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/xstream.html">XStream算法SDK编程框架开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/xproto.html">XProto原型应用开发框架开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/solution.html">场景参考解决方案</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/tools.html">工具集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/version.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../BuildAll/doc/copyright.html">版权声明</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">AI Express用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>NumPy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../../_sources/common/pybind11/docs/advanced/pycpp/numpy.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="numpy">
<span id="id1"></span><h1>NumPy<a class="headerlink" href="#numpy" title="永久链接至标题">¶</a></h1>
<div class="section" id="buffer-protocol">
<h2>Buffer protocol<a class="headerlink" href="#buffer-protocol" title="永久链接至标题">¶</a></h2>
<p>Python supports an extremely general and convenient approach for exchanging
data between plugin libraries. Types can expose a buffer view <a class="footnote-reference brackets" href="#f2" id="id2">1</a>, which
provides fast direct access to the raw internal data representation. Suppose we
want to bind the following simplistic Matrix class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Matrix</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cols</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">m_cols</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">data</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">rows</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_rows</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">cols</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_cols</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">size_t</span> <span class="n">m_rows</span><span class="p">,</span> <span class="n">m_cols</span><span class="p">;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The following binding code exposes the <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> contents as a buffer object,
making it possible to cast Matrices into NumPy arrays. It is even possible to
completely avoid copy operations with Python expressions like
<code class="docutils literal notranslate"><span class="pre">np.array(matrix_instance,</span> <span class="pre">copy</span> <span class="pre">=</span> <span class="pre">False)</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Matrix&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_protocol</span><span class="p">())</span>
   <span class="p">.</span><span class="n">def_buffer</span><span class="p">([](</span><span class="n">Matrix</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="p">(</span>
            <span class="n">m</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>                               <span class="cm">/* Pointer to buffer */</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>                          <span class="cm">/* Size of one scalar */</span>
            <span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(),</span> <span class="cm">/* Python struct-style format descriptor */</span>
            <span class="mi">2</span><span class="p">,</span>                                      <span class="cm">/* Number of dimensions */</span>
            <span class="p">{</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="p">},</span>                 <span class="cm">/* Buffer dimensions */</span>
            <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">(),</span>             <span class="cm">/* Strides (in bytes) for each index */</span>
              <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>Supporting the buffer protocol in a new type involves specifying the special
<code class="docutils literal notranslate"><span class="pre">py::buffer_protocol()</span></code> tag in the <code class="docutils literal notranslate"><span class="pre">py::class_</span></code> constructor and calling the
<code class="docutils literal notranslate"><span class="pre">def_buffer()</span></code> method with a lambda function that creates a
<code class="docutils literal notranslate"><span class="pre">py::buffer_info</span></code> description record on demand describing a given matrix
instance. The contents of <code class="docutils literal notranslate"><span class="pre">py::buffer_info</span></code> mirror the Python buffer protocol
specification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">buffer_info</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">itemsize</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">ndim</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">ssize_t</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">ssize_t</span><span class="o">&gt;</span> <span class="n">strides</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To create a C++ function that can take a Python buffer object as an argument,
simply use the type <code class="docutils literal notranslate"><span class="pre">py::buffer</span></code> as one of its arguments. Buffers can exist
in a great variety of configurations, hence some safety checks are usually
necessary in the function body. Below, you can see an basic example on how to
define a custom constructor for the Eigen double precision matrix
(<code class="docutils literal notranslate"><span class="pre">Eigen::MatrixXd</span></code>) type, which supports initialization from compatible
buffer objects (e.g. a NumPy matrix).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Bind MatrixXd (or some other Eigen type) to Python */</span>
<span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">Matrix</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matrix</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">rowMajor</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">::</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">RowMajorBit</span><span class="p">;</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Matrix&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_protocol</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__init__&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">Matrix</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Stride</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">Strides</span><span class="p">;</span>

        <span class="cm">/* Request a buffer descriptor from Python */</span>
        <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span> <span class="n">info</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

        <span class="cm">/* Some sanity checks ... */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">format</span> <span class="o">!=</span> <span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Incompatible format: expected a double array!&quot;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Incompatible buffer dimension!&quot;</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">strides</span> <span class="o">=</span> <span class="n">Strides</span><span class="p">(</span>
            <span class="n">info</span><span class="p">.</span><span class="n">strides</span><span class="p">[</span><span class="n">rowMajor</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">),</span>
            <span class="n">info</span><span class="p">.</span><span class="n">strides</span><span class="p">[</span><span class="n">rowMajor</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">));</span>

        <span class="k">auto</span> <span class="n">map</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Strides</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Scalar</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span> <span class="n">info</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">strides</span><span class="p">);</span>

        <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>For reference, the <code class="docutils literal notranslate"><span class="pre">def_buffer()</span></code> call for this Eigen data type should look
as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def_buffer</span><span class="p">([](</span><span class="n">Matrix</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="p">(</span>
        <span class="n">m</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>                                <span class="cm">/* Pointer to buffer */</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">),</span>                          <span class="cm">/* Size of one scalar */</span>
        <span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(),</span> <span class="cm">/* Python struct-style format descriptor */</span>
        <span class="mi">2</span><span class="p">,</span>                                       <span class="cm">/* Number of dimensions */</span>
        <span class="p">{</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="p">},</span>                  <span class="cm">/* Buffer dimensions */</span>
        <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rowMajor</span> <span class="o">?</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
          <span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rowMajor</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">())</span> <span class="p">}</span>
                                                 <span class="cm">/* Strides (in bytes) for each index */</span>
    <span class="p">);</span>
 <span class="p">})</span>
</pre></div>
</div>
<p>For a much easier approach of binding Eigen types (although with some
limitations), refer to the section on <span class="xref std std-doc">/advanced/cast/eigen</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_buffers.cpp</span></code> contains a complete example
that demonstrates using the buffer protocol with pybind11 in more detail.</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p><a class="reference external" href="http://docs.python.org/3/c-api/buffer.html">http://docs.python.org/3/c-api/buffer.html</a></p>
</dd>
</dl>
</div>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="永久链接至标题">¶</a></h2>
<p>By exchanging <code class="docutils literal notranslate"><span class="pre">py::buffer</span></code> with <code class="docutils literal notranslate"><span class="pre">py::array</span></code> in the above snippet, we can
restrict the function so that it only accepts NumPy arrays (rather than any
type of Python object satisfying the buffer protocol).</p>
<p>In many situations, we want to define a function which only accepts a NumPy
array of a certain data type. This is possible via the <code class="docutils literal notranslate"><span class="pre">py::array_t&lt;T&gt;</span></code>
template. For instance, the following function requires the argument to be a
NumPy array containing double precision values.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">);</span>
</pre></div>
</div>
<p>When it is invoked with a different type (e.g. an integer or a list of
integers), the binding code will attempt to cast the input into a NumPy array
of the requested type. Note that this feature requires the
<code class="file docutils literal notranslate"><span class="pre">pybind11/numpy.h</span></code> header to be included.</p>
<p>Data in NumPy arrays is not guaranteed to packed in a dense manner;
furthermore, entries can be separated by arbitrary column and row strides.
Sometimes, it can be useful to require a function to only accept dense arrays
using either the C (row-major) or Fortran (column-major) ordering. This can be
accomplished via a second template argument with values <code class="docutils literal notranslate"><span class="pre">py::array::c_style</span></code>
or <code class="docutils literal notranslate"><span class="pre">py::array::f_style</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="o">::</span><span class="n">c_style</span> <span class="o">|</span> <span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="o">::</span><span class="n">forcecast</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">py::array::forcecast</span></code> argument is the default value of the second
template parameter, and it ensures that non-conforming arguments are converted
into an array satisfying the specified requirements instead of trying the next
function overload.</p>
</div>
<div class="section" id="structured-types">
<h2>Structured types<a class="headerlink" href="#structured-types" title="永久链接至标题">¶</a></h2>
<p>In order for <code class="docutils literal notranslate"><span class="pre">py::array_t</span></code> to work with structured (record) types, we first
need to register the memory layout of the type. This can be done via
<code class="docutils literal notranslate"><span class="pre">PYBIND11_NUMPY_DTYPE</span></code> macro, called in the plugin definition code, which
expects the type followed by field names:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ...</span>
<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="n">PYBIND11_NUMPY_DTYPE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">PYBIND11_NUMPY_DTYPE</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="cm">/* now both A and B can be used as template arguments to py::array_t */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The structure should consist of fundamental arithmetic types, <code class="docutils literal notranslate"><span class="pre">std::complex</span></code>,
previously registered substructures, and arrays of any of the above. Both C++
arrays and <code class="docutils literal notranslate"><span class="pre">std::array</span></code> are supported. While there is a static assertion to
prevent many types of unsupported structures, it is still the user’s
responsibility to use only “plain” structures that can be safely manipulated as
raw memory without violating invariants.</p>
</div>
<div class="section" id="vectorizing-functions">
<h2>Vectorizing functions<a class="headerlink" href="#vectorizing-functions" title="永久链接至标题">¶</a></h2>
<p>Suppose we want to bind a function with the following signature to Python so
that it can process arbitrary NumPy array arguments (vectors, matrices, general
N-D arrays) in addition to its normal arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">my_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>After including the <code class="docutils literal notranslate"><span class="pre">pybind11/numpy.h</span></code> header, this is extremely simple:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;vectorized_func&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">vectorize</span><span class="p">(</span><span class="n">my_func</span><span class="p">));</span>
</pre></div>
</div>
<p>Invoking the function like below causes 4 calls to be made to <code class="docutils literal notranslate"><span class="pre">my_func</span></code> with
each of the array elements. The significant advantage of this compared to
solutions like <code class="docutils literal notranslate"><span class="pre">numpy.vectorize()</span></code> is that the loop over the elements runs
entirely on the C++ side and can be crunched down into a tight, optimized loop
by the compiler. The result is returned as a NumPy array of type
<code class="docutils literal notranslate"><span class="pre">numpy.dtype.float64</span></code>.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">vectorized_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>The scalar argument <code class="docutils literal notranslate"><span class="pre">z</span></code> is transparently replicated 4 times.  The input
arrays <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are automatically converted into the right types (they
are of type  <code class="docutils literal notranslate"><span class="pre">numpy.dtype.int64</span></code> but need to be <code class="docutils literal notranslate"><span class="pre">numpy.dtype.int32</span></code> and
<code class="docutils literal notranslate"><span class="pre">numpy.dtype.float32</span></code>, respectively).</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Only arithmetic, complex, and POD types passed by value or by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">&amp;</span></code>
reference are vectorized; all other arguments are passed through as-is.
Functions taking rvalue reference arguments cannot be vectorized.</p>
</div>
<p>In cases where the computation is too complicated to be reduced to
<code class="docutils literal notranslate"><span class="pre">vectorize</span></code>, it will be necessary to create and access the buffer contents
manually. The following snippet contains a complete example that shows how this
works (the code is somewhat contrived, since it could have been done more
simply using <code class="docutils literal notranslate"><span class="pre">vectorize</span></code>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;pybind11/pybind11.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pybind11/numpy.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">py</span> <span class="o">=</span> <span class="n">pybind11</span><span class="p">;</span>

<span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">add_arrays</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">input1</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">input2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span> <span class="n">buf1</span> <span class="o">=</span> <span class="n">input1</span><span class="p">.</span><span class="n">request</span><span class="p">(),</span> <span class="n">buf2</span> <span class="o">=</span> <span class="n">input2</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">buf2</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Number of dimensions must be one&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">buf2</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Input shapes must match&quot;</span><span class="p">);</span>

    <span class="cm">/* No pointer is passed, so NumPy will allocate the buffer */</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

    <span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span> <span class="n">buf3</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

    <span class="kt">double</span> <span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf1</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
           <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf2</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
           <span class="o">*</span><span class="n">ptr3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf3</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buf1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ptr3</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;add_arrays&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">add_arrays</span><span class="p">,</span> <span class="s">&quot;Add two NumPy arrays&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_numpy_vectorize.cpp</span></code> contains a complete
example that demonstrates using <code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code> in more detail.</p>
</div>
</div>
<div class="section" id="direct-access">
<h2>Direct access<a class="headerlink" href="#direct-access" title="永久链接至标题">¶</a></h2>
<p>For performance reasons, particularly when dealing with very large arrays, it
is often desirable to directly access array elements without internal checking
of dimensions and bounds on every access when indices are known to be already
valid.  To avoid such checks, the <code class="docutils literal notranslate"><span class="pre">array</span></code> class and <code class="docutils literal notranslate"><span class="pre">array_t&lt;T&gt;</span></code> template
class offer an unchecked proxy object that can be used for this unchecked
access through the <code class="docutils literal notranslate"><span class="pre">unchecked&lt;N&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">mutable_unchecked&lt;N&gt;</span></code> methods,
where <code class="docutils literal notranslate"><span class="pre">N</span></code> gives the required dimensionality of the array:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;sum_3d&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">unchecked</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// x must have ndim = 3; can be non-writeable</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;increment_3d&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">mutable_unchecked</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Will throw if ndim != 3 or flags.writeable is false</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">ssize_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">().</span><span class="n">noconvert</span><span class="p">());</span>
</pre></div>
</div>
<p>To obtain the proxy from an <code class="docutils literal notranslate"><span class="pre">array</span></code> object, you must specify both the data
type and number of dimensions as template arguments, such as <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">r</span> <span class="pre">=</span>
<span class="pre">myarray.mutable_unchecked&lt;float,</span> <span class="pre">2&gt;()</span></code>.</p>
<p>If the number of dimensions is not known at compile time, you can omit the
dimensions template parameter (i.e. calling <code class="docutils literal notranslate"><span class="pre">arr_t.unchecked()</span></code> or
<code class="docutils literal notranslate"><span class="pre">arr.unchecked&lt;T&gt;()</span></code>.  This will give you a proxy object that works in the
same way, but results in less optimizable code and thus a small efficiency
loss in tight loops.</p>
<p>Note that the returned proxy object directly references the array’s data, and
only reads its shape, strides, and writeable flag when constructed.  You must
take care to ensure that the referenced array is not destroyed or reshaped for
the duration of the returned object, typically by limiting the scope of the
returned instance.</p>
<p>The returned proxy object supports some of the same methods as <code class="docutils literal notranslate"><span class="pre">py::array</span></code> so
that it can be used as a drop-in replacement for some existing, index-checked
uses of <code class="docutils literal notranslate"><span class="pre">py::array</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r.ndim()</span></code> returns the number of dimensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r.data(1,</span> <span class="pre">2,</span> <span class="pre">...)</span></code> and <code class="docutils literal notranslate"><span class="pre">r.mutable_data(1,</span> <span class="pre">2,</span> <span class="pre">...)`</span></code> returns a pointer to
the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T</span></code> or <code class="docutils literal notranslate"><span class="pre">T</span></code> data, respectively, at the given indices.  The
latter is only available to proxies obtained via <code class="docutils literal notranslate"><span class="pre">a.mutable_unchecked()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">itemsize()</span></code> returns the size of an item in bytes, i.e. <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ndim()</span></code> returns the number of dimensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shape(n)</span></code> returns the size of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size()</span></code> returns the total number of elements (i.e. the product of the shapes).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nbytes()</span></code> returns the number of bytes used by the referenced elements
(i.e. <code class="docutils literal notranslate"><span class="pre">itemsize()</span></code> times <code class="docutils literal notranslate"><span class="pre">size()</span></code>).</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_numpy_array.cpp</span></code> contains additional examples
demonstrating the use of this feature.</p>
</div>
</div>
<div class="section" id="ellipsis">
<h2>Ellipsis<a class="headerlink" href="#ellipsis" title="永久链接至标题">¶</a></h2>
<p>Python 3 provides a convenient <code class="docutils literal notranslate"><span class="pre">...</span></code> ellipsis notation that is often used to
slice multidimensional arrays. For instance, the following snippet extracts the
middle dimensions of a tensor with the first and last index set to zero.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="c1"># a NumPy array</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">py::ellipsis()</span></code> function can be used to perform the same
operation on the C++ side:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">array</span> <span class="n">a</span> <span class="o">=</span> <span class="cm">/* A NumPy array */</span><span class="p">;</span>
<span class="n">py</span><span class="o">::</span><span class="n">array</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">py</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">ellipsis</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)];</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, Horizon Robotics

    </p>
  </div>
    
    
    
    利用 <a href="http://sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>