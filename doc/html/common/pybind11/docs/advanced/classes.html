

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; AI Express用户手册 2.7.0 文档</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> AI Express用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/quick_start.html">快速上手</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xstream.html">XStream算法SDK编程框架开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xproto.html">XProto原型应用开发框架开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/solution.html">场景参考解决方案</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/tools.html">工具集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/version.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/copyright.html">版权声明</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AI Express用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/common/pybind11/docs/advanced/classes.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<h1>Classes<a class="headerlink" href="#classes" title="永久链接至标题">¶</a></h1>
<p>This section presents advanced binding code for classes and it is assumed
that you are already familiar with the basics from <span class="xref std std-doc">/classes</span>.</p>
<div class="section" id="overriding-virtual-functions-in-python">
<span id="overriding-virtuals"></span><h2>Overriding virtual functions in Python<a class="headerlink" href="#overriding-virtual-functions-in-python" title="永久链接至标题">¶</a></h2>
<p>Suppose that a C++ class or interface has a virtual function that we’d like to
to override from within Python (we’ll focus on the class <code class="docutils literal notranslate"><span class="pre">Animal</span></code>; <code class="docutils literal notranslate"><span class="pre">Dog</span></code> is
given as a specific example of how one would do this with traditional C++
code).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n_times</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;woof! &quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Let’s also suppose that we are given a plain function which calls the
function <code class="docutils literal notranslate"><span class="pre">go()</span></code> on an arbitrary <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">call_go</span><span class="p">(</span><span class="n">Animal</span> <span class="o">*</span><span class="n">animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">animal</span><span class="o">-&gt;</span><span class="n">go</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Normally, the binding code for these classes would look as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Animal&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Animal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span>

    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span> <span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>

    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;call_go&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_go</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, these bindings are impossible to extend: <code class="docutils literal notranslate"><span class="pre">Animal</span></code> is not
constructible, and we clearly require some kind of “trampoline” that
redirects virtual calls back to Python.</p>
<p>Defining a new type of <code class="docutils literal notranslate"><span class="pre">Animal</span></code> from within Python is possible but requires a
helper class that is defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PyAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* Inherit the constructors */</span>
    <span class="k">using</span> <span class="n">Animal</span><span class="o">::</span><span class="n">Animal</span><span class="p">;</span>

    <span class="cm">/* Trampoline (need one for each virtual function) */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">PYBIND11_OVERLOAD_PURE</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="cm">/* Return type */</span>
            <span class="n">Animal</span><span class="p">,</span>      <span class="cm">/* Parent class */</span>
            <span class="n">go</span><span class="p">,</span>          <span class="cm">/* Name of function in C++ (must match Python name) */</span>
            <span class="n">n_times</span>      <span class="cm">/* Argument(s) */</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD_PURE</span></code> should be used for pure virtual
functions, and <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD</span></code> should be used for functions which have
a default implementation.  There are also two alternate macros
<code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD_PURE_NAME</span></code> and <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD_NAME</span></code> which
take a string-valued name argument between the <em>Parent class</em> and <em>Name of the
function</em> slots, which defines the name of function in Python. This is required
when the C++ and Python versions of the
function have different names, e.g.  <code class="docutils literal notranslate"><span class="pre">operator()</span></code> vs <code class="docutils literal notranslate"><span class="pre">__call__</span></code>.</p>
<p>The binding code also needs a few minor adaptations (highlighted):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span> <span class="n">PyAnimal</span> <span class="cm">/* &lt;--- trampoline*/</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Animal&quot;</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
</span>        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Animal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span>

    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span> <span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>

    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;call_go&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_go</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Importantly, pybind11 is made aware of the trampoline helper class by
specifying it as an extra template argument to <code class="xref py py-class docutils literal notranslate"><span class="pre">class_</span></code>. (This can also
be combined with other template arguments such as a custom holder type; the
order of template types does not matter).  Following this, we are able to
define a constructor as usual.</p>
<p>Bindings should be made against the actual class, not the trampoline helper class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span> <span class="n">PyAnimal</span> <span class="cm">/* &lt;--- trampoline*/</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Animal&quot;</span><span class="p">);</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
<span class="hll">    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyAnimal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span> <span class="cm">/* &lt;--- THIS IS WRONG, use &amp;Animal::go */</span>
</span></pre></div>
</div>
<p>Note, however, that the above is sufficient for allowing python classes to
extend <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, but not <code class="docutils literal notranslate"><span class="pre">Dog</span></code>: see <a class="reference internal" href="#virtual-and-inheritance"><span class="std std-ref">Combining virtual functions and inheritance</span></a> for the
necessary steps required to providing proper overload support for inherited
classes.</p>
<p>The Python session below shows how to override <code class="docutils literal notranslate"><span class="pre">Animal::go</span></code> and invoke it via
a virtual method call.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_go</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">u&#39;woof! woof! woof! &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Cat</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_times</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="s2">&quot;meow! &quot;</span> <span class="o">*</span> <span class="n">n_times</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_go</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">u&#39;meow! meow! meow! &#39;</span>
</pre></div>
</div>
<p>If you are defining a custom constructor in a derived Python class, you <em>must</em>
ensure that you explicitly call the bound C++ constructor using <code class="docutils literal notranslate"><span class="pre">__init__</span></code>,
<em>regardless</em> of whether it is a default constructor or not. Otherwise, the
memory for the C++ portion of the instance will be left uninitialized, which
will generally leave the C++ instance in an invalid state and cause undefined
behavior if the C++ instance is subsequently used.</p>
<p>Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dachshund</span><span class="p">(</span><span class="n">Dog</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">Dog</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># Without this, undefined behavior may occur if the C++ portions are referenced.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">def</span> <span class="nf">bark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;yap!&quot;</span>
</pre></div>
</div>
<p>Note that a direct <code class="docutils literal notranslate"><span class="pre">__init__</span></code> constructor <em>should be called</em>, and <code class="docutils literal notranslate"><span class="pre">super()</span></code>
should not be used. For simple cases of linear inheritance, <code class="docutils literal notranslate"><span class="pre">super()</span></code>
may work, but once you begin mixing Python and C++ multiple inheritance,
things will fall apart due to differences between Python’s MRO and C++’s
mechanisms.</p>
<p>Please take a look at the <a class="reference internal" href="misc.html#macro-notes"><span class="std std-ref">General notes regarding convenience macros</span></a> before using this feature.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>When the overridden type returns a reference or pointer to a type that
pybind11 converts from Python (for example, numeric values, std::string,
and other built-in value-converting types), there are some limitations to
be aware of:</p>
<ul class="simple">
<li><p>because in these cases there is no C++ variable to reference (the value
is stored in the referenced Python variable), pybind11 provides one in
the PYBIND11_OVERLOAD macros (when needed) with static storage duration.
Note that this means that invoking the overloaded method on <em>any</em>
instance will change the referenced value stored in <em>all</em> instances of
that type.</p></li>
<li><p>Attempts to modify a non-const reference will not have the desired
effect: it will change only the static cache variable, but this change
will not propagate to underlying Python instance, and the change will be
replaced the next time the overload is invoked.</p></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> contains a complete
example that demonstrates how to override virtual functions using pybind11
in more detail.</p>
</div>
</div>
<div class="section" id="combining-virtual-functions-and-inheritance">
<span id="virtual-and-inheritance"></span><h2>Combining virtual functions and inheritance<a class="headerlink" href="#combining-virtual-functions-and-inheritance" title="永久链接至标题">¶</a></h2>
<p>When combining virtual methods with inheritance, you need to be sure to provide
an override for each method for which you want to allow overrides from derived
python classes.  For example, suppose we extend the above <code class="docutils literal notranslate"><span class="pre">Animal</span></code>/<code class="docutils literal notranslate"><span class="pre">Dog</span></code>
example as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n_times</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">bark</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bark</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;woof!&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>then the trampoline class for <code class="docutils literal notranslate"><span class="pre">Animal</span></code> must, as described in the previous
section, override <code class="docutils literal notranslate"><span class="pre">go()</span></code> and <code class="docutils literal notranslate"><span class="pre">name()</span></code>, but in order to allow python code to
inherit properly from <code class="docutils literal notranslate"><span class="pre">Dog</span></code>, we also need a trampoline class for <code class="docutils literal notranslate"><span class="pre">Dog</span></code> that
overrides both the added <code class="docutils literal notranslate"><span class="pre">bark()</span></code> method <em>and</em> the <code class="docutils literal notranslate"><span class="pre">go()</span></code> and <code class="docutils literal notranslate"><span class="pre">name()</span></code>
methods inherited from <code class="docutils literal notranslate"><span class="pre">Animal</span></code> (even though <code class="docutils literal notranslate"><span class="pre">Dog</span></code> doesn’t directly
override the <code class="docutils literal notranslate"><span class="pre">name()</span></code> method):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PyAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Animal</span><span class="o">::</span><span class="n">Animal</span><span class="p">;</span> <span class="c1">// Inherit constructors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Animal</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">n_times</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Animal</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">PyDog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Dog</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">;</span> <span class="c1">// Inherit constructors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">n_times</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bark</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">bark</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Note the trailing commas in the <code class="docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD</span></code> calls to <code class="docutils literal notranslate"><span class="pre">name()</span></code>
and <code class="docutils literal notranslate"><span class="pre">bark()</span></code>. These are needed to portably implement a trampoline for a
function that does not take any arguments. For functions that take
a nonzero number of arguments, the trailing comma must be omitted.</p>
</div>
<p>A registered class derived from a pybind11-registered class with virtual
methods requires a similar trampoline class, <em>even if</em> it doesn’t explicitly
declare or override any virtual methods itself:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Husky</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Dog</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">PyHusky</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Husky</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Husky</span><span class="o">::</span><span class="n">Husky</span><span class="p">;</span> <span class="c1">// Inherit constructors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Husky</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">n_times</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Husky</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bark</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Husky</span><span class="p">,</span> <span class="n">bark</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There is, however, a technique that can be used to avoid this duplication
(which can be especially helpful for a base class with several virtual
methods).  The technique involves using template trampoline classes, as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">AnimalBase</span> <span class="o">=</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">PyAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AnimalBase</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">AnimalBase</span><span class="o">::</span><span class="n">AnimalBase</span><span class="p">;</span> <span class="c1">// Inherit constructors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">AnimalBase</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">n_times</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">AnimalBase</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DogBase</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">PyDog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PyAnimal</span><span class="o">&lt;</span><span class="n">DogBase</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">PyAnimal</span><span class="o">&lt;</span><span class="n">DogBase</span><span class="o">&gt;::</span><span class="n">PyAnimal</span><span class="p">;</span> <span class="c1">// Inherit constructors</span>
    <span class="c1">// Override PyAnimal&#39;s pure virtual go() with a non-pure one:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">DogBase</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">n_times</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bark</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">DogBase</span><span class="p">,</span> <span class="n">bark</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This technique has the advantage of requiring just one trampoline method to be
declared per virtual method and pure virtual method override.  It does,
however, require the compiler to generate at least as many methods (and
possibly more, if both pure virtual and overridden pure virtual methods are
exposed, as above).</p>
<p>The classes are then registered with pybind11 using:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span> <span class="n">PyAnimal</span><span class="o">&lt;&gt;&gt;</span> <span class="n">animal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Animal&quot;</span><span class="p">);</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span> <span class="n">PyDog</span><span class="o">&lt;&gt;&gt;</span> <span class="n">dog</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">);</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Husky</span><span class="p">,</span> <span class="n">PyDog</span><span class="o">&lt;</span><span class="n">Husky</span><span class="o">&gt;&gt;</span> <span class="n">husky</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Husky&quot;</span><span class="p">);</span>
<span class="c1">// ... add animal, dog, husky definitions</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">Husky</span></code> did not require a dedicated trampoline template class at
all, since it neither declares any new virtual methods nor provides any pure
virtual method implementations.</p>
<p>With either the repeated-virtuals or templated trampoline methods in place, you
can now create a python class that inherits from <code class="docutils literal notranslate"><span class="pre">Dog</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ShihTzu</span><span class="p">(</span><span class="n">Dog</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;yip!&quot;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>See the file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> for complete examples
using both the duplication and templated trampoline approaches.</p>
</div>
</div>
<div class="section" id="extended-trampoline-class-functionality">
<span id="extended-aliases"></span><h2>Extended trampoline class functionality<a class="headerlink" href="#extended-trampoline-class-functionality" title="永久链接至标题">¶</a></h2>
<div class="section" id="forced-trampoline-class-initialisation">
<span id="extended-class-functionality-forced-trampoline"></span><h3>Forced trampoline class initialisation<a class="headerlink" href="#forced-trampoline-class-initialisation" title="永久链接至标题">¶</a></h3>
<p>The trampoline classes described in the previous sections are, by default, only
initialized when needed.  More specifically, they are initialized when a python
class actually inherits from a registered type (instead of merely creating an
instance of the registered type), or when a registered constructor is only
valid for the trampoline class but not the registered class.  This is primarily
for performance reasons: when the trampoline class is not needed for anything
except virtual method dispatching, not initializing the trampoline class
improves performance by avoiding needing to do a run-time check to see if the
inheriting python instance has an overloaded method.</p>
<p>Sometimes, however, it is useful to always initialize a trampoline class as an
intermediate class that does more than just handle virtual method dispatching.
For example, such a class might perform extra class initialization, extra
destruction operations, and might define new members and methods to enable a
more python-like interface to a class.</p>
<p>In order to tell pybind11 that it should <em>always</em> initialize the trampoline
class when creating new instances of a type, the class constructors should be
declared using <code class="docutils literal notranslate"><span class="pre">py::init_alias&lt;Args,</span> <span class="pre">...&gt;()</span></code> instead of the usual
<code class="docutils literal notranslate"><span class="pre">py::init&lt;Args,</span> <span class="pre">...&gt;()</span></code>.  This forces construction via the trampoline class,
ensuring member initialization and (eventual) destruction.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>See the file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> for complete examples
showing both normal and forced trampoline instantiation.</p>
</div>
</div>
<div class="section" id="different-method-signatures">
<h3>Different method signatures<a class="headerlink" href="#different-method-signatures" title="永久链接至标题">¶</a></h3>
<p>The macro’s introduced in <a class="reference internal" href="#overriding-virtuals"><span class="std std-ref">Overriding virtual functions in Python</span></a> cover most of the standard
use cases when exposing C++ classes to Python. Sometimes it is hard or unwieldy
to create a direct one-on-one mapping between the arguments and method return
type.</p>
<p>An example would be when the C++ signature contains output arguments using
references (See also <a class="reference internal" href="../faq.html#faq-reference-arguments"><span class="std std-ref">Limitations involving reference arguments</span></a>). Another way of solving
this is to use the method body of the trampoline class to do conversions to the
input and return of the Python method.</p>
<p>The main building block to do so is the <code class="xref py py-func docutils literal notranslate"><span class="pre">get_overload()</span></code>, this function
allows retrieving a method implemented in Python from within the trampoline’s
methods. Consider for example a C++ method which has the signature
<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">myMethod(int32_t&amp;</span> <span class="pre">value)</span></code>, where the return indicates whether
something should be done with the <code class="docutils literal notranslate"><span class="pre">value</span></code>. This can be made convenient on the
Python side by allowing the Python function to return <code class="docutils literal notranslate"><span class="pre">None</span></code> or an <code class="docutils literal notranslate"><span class="pre">int</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">myMethod</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pybind11</span><span class="o">::</span><span class="n">gil_scoped_acquire</span> <span class="n">gil</span><span class="p">;</span>  <span class="c1">// Acquire the GIL while in this scope.</span>
    <span class="c1">// Try to look up the overloaded method on the Python side.</span>
    <span class="n">pybind11</span><span class="o">::</span><span class="n">function</span> <span class="n">overload</span> <span class="o">=</span> <span class="n">pybind11</span><span class="o">::</span><span class="n">get_overload</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;myMethod&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">overload</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// method is found</span>
        <span class="k">auto</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">overload</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// Call the Python function.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">isinstance</span><span class="o">&lt;</span><span class="n">py</span><span class="o">::</span><span class="n">int_</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// check if it returned a Python integer type</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// Cast it and assign it to the value.</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Return true; value should be used.</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Python returned none, return false.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Alternatively return MyClass::myMethod(value);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="custom-constructors">
<span id="id1"></span><h2>Custom constructors<a class="headerlink" href="#custom-constructors" title="永久链接至标题">¶</a></h2>
<p>The syntax for binding constructors was previously introduced, but it only
works when a constructor of the appropriate arguments actually exists on the
C++ side.  To extend this to more general cases, pybind11 makes it possible
to bind factory functions as constructors. For example, suppose you have a
class like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// private constructor</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Factory function:</span>
    <span class="k">static</span> <span class="n">Example</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Example</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Example&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Example</span><span class="o">::</span><span class="n">create</span><span class="p">));</span>
</pre></div>
</div>
<p>While it is possible to create a straightforward binding of the static
<code class="docutils literal notranslate"><span class="pre">create</span></code> method, it may sometimes be preferable to expose it as a constructor
on the Python side. This can be accomplished by calling <code class="docutils literal notranslate"><span class="pre">.def(py::init(...))</span></code>
with the function reference returning the new instance passed as an argument.
It is also possible to use this approach to bind a function returning a new
instance by raw pointer or by the holder (e.g. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>).</p>
<p>The following example shows the different approaches:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// private constructor</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Factory function - returned by value:</span>
    <span class="k">static</span> <span class="n">Example</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Example</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>

    <span class="c1">// These constructors are publicly callable:</span>
    <span class="n">Example</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="n">Example</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Example&quot;</span><span class="p">)</span>
    <span class="c1">// Bind the factory function as a constructor:</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Example</span><span class="o">::</span><span class="n">create</span><span class="p">))</span>
    <span class="c1">// Bind a lambda function returning a pointer wrapped in a holder:</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Example</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
    <span class="p">}))</span>
    <span class="c1">// Return a raw pointer:</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Example</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="p">}))</span>
    <span class="c1">// You can mix the above with regular C++ constructor bindings as well:</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>When the constructor is invoked from Python, pybind11 will call the factory
function and store the resulting C++ instance in the Python instance.</p>
<p>When combining factory functions constructors with <a class="reference internal" href="#overriding-virtuals"><span class="std std-ref">virtual function
trampolines</span></a> there are two approaches.  The first is to
add a constructor to the alias class that takes a base value by
rvalue-reference.  If such a constructor is available, it will be used to
construct an alias instance from the value returned by the factory function.
The second option is to provide two factory functions to <code class="docutils literal notranslate"><span class="pre">py::init()</span></code>: the
first will be invoked when no alias class is required (i.e. when the class is
being used but not inherited from in Python), and the second will be invoked
when an alias is required.</p>
<p>You can also specify a single factory function that always returns an alias
instance: this will result in behaviour similar to <code class="docutils literal notranslate"><span class="pre">py::init_alias&lt;...&gt;()</span></code>,
as described in the <a class="reference internal" href="#extended-aliases"><span class="std std-ref">extended trampoline class documentation</span></a>.</p>
<p>The following example shows the different factory approaches for a class with
an alias:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;pybind11/factory.h&gt;</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Example</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">PyExample</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Example</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Example</span><span class="o">::</span><span class="n">Example</span><span class="p">;</span>
    <span class="n">PyExample</span><span class="p">(</span><span class="n">Example</span> <span class="o">&amp;&amp;</span><span class="n">base</span><span class="p">)</span> <span class="o">:</span> <span class="n">Example</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="p">,</span> <span class="n">PyExample</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Example&quot;</span><span class="p">)</span>
    <span class="c1">// Returns an Example pointer.  If a PyExample is needed, the Example</span>
    <span class="c1">// instance will be moved via the extra constructor in PyExample, above.</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Example</span><span class="p">();</span> <span class="p">}))</span>
    <span class="c1">// Two callbacks:</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Example</span><span class="p">();</span> <span class="p">}</span> <span class="cm">/* no alias needed */</span><span class="p">,</span>
                  <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">PyExample</span><span class="p">();</span> <span class="p">}</span> <span class="cm">/* alias needed */</span><span class="p">))</span>
    <span class="c1">// *Always* returns an alias instance (like py::init_alias&lt;&gt;())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">PyExample</span><span class="p">();</span> <span class="p">}))</span>
    <span class="p">;</span>
</pre></div>
</div>
<div class="section" id="brace-initialization">
<h3>Brace initialization<a class="headerlink" href="#brace-initialization" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pybind11::init&lt;&gt;</span></code> internally uses C++11 brace initialization to call the
constructor of the target class. This means that it can be used to bind
<em>implicit</em> constructors as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Aggregate</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Aggregate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Aggregate&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Note that brace initialization preferentially invokes constructor overloads
taking a <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>. In the rare event that this causes an
issue, you can work around it by using <code class="docutils literal notranslate"><span class="pre">py::init(...)</span></code> with a lambda
function that constructs the new object as desired.</p>
</div>
</div>
</div>
<div class="section" id="non-public-destructors">
<span id="classes-with-non-public-destructors"></span><h2>Non-public destructors<a class="headerlink" href="#non-public-destructors" title="永久链接至标题">¶</a></h2>
<p>If a class has a private or protected destructor (as might e.g. be the case in
a singleton pattern), a compile error will occur when creating bindings via
pybind11. The underlying issue is that the <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> holder type that
is responsible for managing the lifetime of instances will reference the
destructor even if no deallocations ever take place. In order to expose classes
with private or protected destructors, it is possible to override the holder
type via a holder type argument to <code class="docutils literal notranslate"><span class="pre">class_</span></code>. Pybind11 provides a helper class
<code class="docutils literal notranslate"><span class="pre">py::nodelete</span></code> that disables any destructor invocations. In this case, it is
crucial that instances are deallocated on the C++ side to avoid memory leaks.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ... definition ... */</span>

<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* ... binding code ... */</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">nodelete</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="implicit-conversions">
<span id="id2"></span><h2>Implicit conversions<a class="headerlink" href="#implicit-conversions" title="永久链接至标题">¶</a></h2>
<p>Suppose that instances of two types <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are used in a project, and
that an <code class="docutils literal notranslate"><span class="pre">A</span></code> can easily be converted into an instance of type <code class="docutils literal notranslate"><span class="pre">B</span></code> (examples of this
could be a fixed and an arbitrary precision number type).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">)</span>
    <span class="c1">/// ... members ...</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="c1">/// ... members ...</span>

<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;func&quot;</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">B</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* .... */</span> <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>To invoke the function <code class="docutils literal notranslate"><span class="pre">func</span></code> using a variable <code class="docutils literal notranslate"><span class="pre">a</span></code> containing an <code class="docutils literal notranslate"><span class="pre">A</span></code>
instance, we’d have to write <code class="docutils literal notranslate"><span class="pre">func(B(a))</span></code> in Python. On the other hand, C++
will automatically apply an implicit type conversion, which makes it possible
to directly write <code class="docutils literal notranslate"><span class="pre">func(a)</span></code>.</p>
<p>In this situation (i.e. where <code class="docutils literal notranslate"><span class="pre">B</span></code> has a constructor that converts from
<code class="docutils literal notranslate"><span class="pre">A</span></code>), the following statement enables similar implicit conversions on the
Python side:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">implicitly_convertible</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Implicit conversions from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code> only work when <code class="docutils literal notranslate"><span class="pre">B</span></code> is a custom
data type that is exposed to Python via pybind11.</p>
<p>To prevent runaway recursion, implicit conversions are non-reentrant: an
implicit conversion invoked as part of another implicit conversion of the
same type (i.e. from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code>) will fail.</p>
</div>
</div>
<div class="section" id="static-properties">
<span id="id3"></span><h2>Static properties<a class="headerlink" href="#static-properties" title="永久链接至标题">¶</a></h2>
<p>The section on <a class="reference internal" href="../classes.html#properties"><span class="std std-ref">Instance and static fields</span></a> discussed the creation of instance properties
that are implemented in terms of C++ getters and setters.</p>
<p>Static properties can also be created in a similar way to expose getters and
setters of static class attributes. Note that the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> argument
also exists in this case and is used to pass the Python <code class="docutils literal notranslate"><span class="pre">type</span></code> subclass
instance. This parameter will often not be needed by the C++ side, and the
following example illustrates how to instantiate a lambda getter function
that ignores it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def_property_readonly_static</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">object</span> <span class="cm">/* self */</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Foo</span><span class="p">();</span> <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-overloading">
<h2>Operator overloading<a class="headerlink" href="#operator-overloading" title="永久链接至标题">¶</a></h2>
<p>Suppose that we’re given the following <code class="docutils literal notranslate"><span class="pre">Vector2</span></code> class with a vector addition
and scalar multiplication operation, all implemented using overloaded operators
in C++.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Vector2</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="n">Vector2</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector2</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">Vector2</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">value</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">Vector2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector2</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Vector2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">*=</span> <span class="n">v</span><span class="p">;</span> <span class="n">y</span> <span class="o">*=</span> <span class="n">v</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">friend</span> <span class="n">Vector2</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector2</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The following snippet shows how the above operators can be conveniently exposed
to Python.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;pybind11/operators.h&gt;</span><span class="cp"></span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Vector2&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span> <span class="o">+</span> <span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span> <span class="o">+=</span> <span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span> <span class="o">*=</span> <span class="kt">float</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="kt">float</span><span class="p">()</span> <span class="o">*</span> <span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span> <span class="o">*</span> <span class="kt">float</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="o">-</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__repr__&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Vector2</span><span class="o">::</span><span class="n">toString</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that a line like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span> <span class="o">*</span> <span class="kt">float</span><span class="p">())</span>
</pre></div>
</div>
<p>is really just short hand notation for</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__mul__&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Vector2</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">is_operator</span><span class="p">())</span>
</pre></div>
</div>
<p>This can be useful for exposing additional operators that don’t exist on the
C++ side, or to perform other types of customization. The <code class="docutils literal notranslate"><span class="pre">py::is_operator</span></code>
flag marker is needed to inform pybind11 that this is an operator, which
returns <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> when invoked with incompatible arguments rather than
throwing a type error.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>To use the more convenient <code class="docutils literal notranslate"><span class="pre">py::self</span></code> notation, the additional
header file <code class="file docutils literal notranslate"><span class="pre">pybind11/operators.h</span></code> must be included.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_operator_overloading.cpp</span></code> contains a
complete example that demonstrates how to work with overloaded operators in
more detail.</p>
</div>
</div>
<div class="section" id="pickling-support">
<span id="pickling"></span><h2>Pickling support<a class="headerlink" href="#pickling-support" title="永久链接至标题">¶</a></h2>
<p>Python’s <code class="docutils literal notranslate"><span class="pre">pickle</span></code> module provides a powerful facility to serialize and
de-serialize a Python object graph into a binary data stream. To pickle and
unpickle C++ classes using pybind11, a <code class="docutils literal notranslate"><span class="pre">py::pickle()</span></code> definition must be
provided. Suppose the class in question has the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pickleable</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Pickleable</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setExtra</span><span class="p">(</span><span class="kt">int</span> <span class="n">extra</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_extra</span> <span class="o">=</span> <span class="n">extra</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">extra</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_extra</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_extra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Pickling support in Python is enabled by defining the <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__getstate__</span></code> methods <a class="footnote-reference brackets" href="#f3" id="id4">1</a>. For pybind11 classes, use <code class="docutils literal notranslate"><span class="pre">py::pickle()</span></code>
to bind these two functions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pickleable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pickleable&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">value</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;extra&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">extra</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;setExtra&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">setExtra</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">pickle</span><span class="p">(</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">Pickleable</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// __getstate__</span>
            <span class="cm">/* Return a tuple that fully encodes the state of the object */</span>
            <span class="k">return</span> <span class="n">py</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">p</span><span class="p">.</span><span class="n">extra</span><span class="p">());</span>
        <span class="p">},</span>
        <span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">tuple</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// __setstate__</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid state!&quot;</span><span class="p">);</span>

            <span class="cm">/* Create a new C++ instance */</span>
            <span class="n">Pickleable</span> <span class="nf">p</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>

            <span class="cm">/* Assign any additional state */</span>
            <span class="n">p</span><span class="p">.</span><span class="n">setExtra</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">));</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code> part of the <code class="docutils literal notranslate"><span class="pre">py::picke()</span></code> definition follows the same
rules as the single-argument version of <code class="docutils literal notranslate"><span class="pre">py::init()</span></code>. The return type can be
a value, pointer or holder type. See <a class="reference internal" href="#custom-constructors"><span class="std std-ref">Custom constructors</span></a> for details.</p>
<p>An instance can now be pickled as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>  <span class="c1"># Use cPickle on Python 2.7</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Pickleable</span><span class="p">(</span><span class="s2">&quot;test_value&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">setExtra</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that only the cPickle module is supported on Python 2.7. The second
argument to <code class="docutils literal notranslate"><span class="pre">dumps</span></code> is also crucial: it selects the pickle protocol version
2, since the older version 1 is not supported. Newer versions are also fine—for
instance, specify <code class="docutils literal notranslate"><span class="pre">-1</span></code> to always use the latest available version. Beware:
failure to follow these instructions will cause important pybind11 memory
allocation routines to be skipped during unpickling, which will likely lead to
memory corruption and/or segmentation faults.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_pickling.cpp</span></code> contains a complete example
that demonstrates how to pickle and unpickle types using pybind11 in more
detail.</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p><a class="reference external" href="http://docs.python.org/3/library/pickle.html#pickling-class-instances">http://docs.python.org/3/library/pickle.html#pickling-class-instances</a></p>
</dd>
</dl>
</div>
<div class="section" id="multiple-inheritance">
<h2>Multiple Inheritance<a class="headerlink" href="#multiple-inheritance" title="永久链接至标题">¶</a></h2>
<p>pybind11 can create bindings for types that derive from multiple base types
(aka. <em>multiple inheritance</em>). To do so, specify all bases in the template
arguments of the <code class="docutils literal notranslate"><span class="pre">class_</span></code> declaration:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyType</span><span class="p">,</span> <span class="n">BaseType1</span><span class="p">,</span> <span class="n">BaseType2</span><span class="p">,</span> <span class="n">BaseType3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyType&quot;</span><span class="p">)</span>
   <span class="p">...</span>
</pre></div>
</div>
<p>The base types can be specified in arbitrary order, and they can even be
interspersed with alias types and holder types (discussed earlier in this
document)—pybind11 will automatically find out which is which. The only
requirement is that the first template argument is the type to be declared.</p>
<p>It is also permitted to inherit multiply from exported C++ classes in Python,
as well as inheriting from multiple Python and/or pybind11-exported classes.</p>
<p>There is one caveat regarding the implementation of this feature:</p>
<p>When only one base type is specified for a C++ type that actually has multiple
bases, pybind11 will assume that it does not participate in multiple
inheritance, which can lead to undefined behavior. In such cases, add the tag
<code class="docutils literal notranslate"><span class="pre">multiple_inheritance</span></code> to the class constructor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyType</span><span class="p">,</span> <span class="n">BaseType2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyType&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">multiple_inheritance</span><span class="p">());</span>
</pre></div>
</div>
<p>The tag is redundant and does not need to be specified when multiple base types
are listed.</p>
</div>
<div class="section" id="module-local-class-bindings">
<span id="module-local"></span><h2>Module-local class bindings<a class="headerlink" href="#module-local-class-bindings" title="永久链接至标题">¶</a></h2>
<p>When creating a binding for a class, pybind11 by default makes that binding
“global” across modules.  What this means is that a type defined in one module
can be returned from any module resulting in the same Python type.  For
example, this allows the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// In the module1.cpp binding code for module1:</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def_readonly</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// In the module2.cpp binding code for module2:</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;create_pet&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Pet</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="p">});</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">module1</span> <span class="kn">import</span> <span class="n">Pet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">module2</span> <span class="kn">import</span> <span class="n">create_pet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet1</span> <span class="o">=</span> <span class="n">Pet</span><span class="p">(</span><span class="s2">&quot;Kitty&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet2</span> <span class="o">=</span> <span class="n">create_pet</span><span class="p">(</span><span class="s2">&quot;Doggy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet2</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;Doggy&#39;</span>
</pre></div>
</div>
<p>When writing binding code for a library, this is usually desirable: this
allows, for example, splitting up a complex library into multiple Python
modules.</p>
<p>In some cases, however, this can cause conflicts.  For example, suppose two
unrelated modules make use of an external C++ library and each provide custom
bindings for one of that library’s classes.  This will result in an error when
a Python program attempts to import both modules (directly or indirectly)
because of conflicting definitions on the external type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// dogs.cpp</span>

<span class="c1">// Binding for external library class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>

<span class="c1">// Binding for local extension class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span> <span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// cats.cpp, in a completely separate project from the above dogs.cpp.</span>

<span class="c1">// Binding for external library class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>

<span class="c1">// Binding for local extending class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">Cat</span><span class="p">,</span> <span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Cat&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dogs</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ImportError</span>: <span class="n">generic_type: type &quot;Pet&quot; is already registered!</span>
</pre></div>
</div>
<p>To get around this, you can tell pybind11 to keep the external class binding
localized to the module by passing the <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> attribute into
the <code class="docutils literal notranslate"><span class="pre">py::class_</span></code> constructor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Pet binding in dogs.cpp:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">module_local</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Pet binding in cats.cpp:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">module_local</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>This makes the Python-side <code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> and <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code> into distinct classes,
avoiding the conflict and allowing both modules to be loaded.  C++ code in the
<code class="docutils literal notranslate"><span class="pre">dogs</span></code> module that casts or returns a <code class="docutils literal notranslate"><span class="pre">Pet</span></code> instance will result in a
<code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> Python instance, while C++ code in the <code class="docutils literal notranslate"><span class="pre">cats</span></code> module will result
in a <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code> Python instance.</p>
<p>This does come with two caveats, however: First, external modules cannot return
or cast a <code class="docutils literal notranslate"><span class="pre">Pet</span></code> instance to Python (unless they also provide their own local
bindings).  Second, from the Python point of view they are two distinct classes.</p>
<p>Note that the locality only applies in the C++ -&gt; Python direction.  When
passing such a <code class="docutils literal notranslate"><span class="pre">py::module_local</span></code> type into a C++ function, the module-local
classes are still considered.  This means that if the following function is
added to any module (including but not limited to the <code class="docutils literal notranslate"><span class="pre">cats</span></code> and <code class="docutils literal notranslate"><span class="pre">dogs</span></code>
modules above) it will be callable with either a <code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> or <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code>
argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;pet_name&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="n">pets</span><span class="o">::</span><span class="n">Pet</span> <span class="o">&amp;</span><span class="n">pet</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pet</span><span class="p">.</span><span class="n">name</span><span class="p">();</span> <span class="p">});</span>
</pre></div>
</div>
<p>For example, suppose the above function is added to each of <code class="docutils literal notranslate"><span class="pre">cats.cpp</span></code>,
<code class="docutils literal notranslate"><span class="pre">dogs.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">frogs.cpp</span></code> (where <code class="docutils literal notranslate"><span class="pre">frogs.cpp</span></code> is some other module that
does <em>not</em> bind <code class="docutils literal notranslate"><span class="pre">Pets</span></code> at all).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cats</span><span class="o">,</span> <span class="nn">dogs</span><span class="o">,</span> <span class="nn">frogs</span>  <span class="c1"># No error because of the added py::module_local()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycat</span><span class="p">,</span> <span class="n">mydog</span> <span class="o">=</span> <span class="n">cats</span><span class="o">.</span><span class="n">Cat</span><span class="p">(</span><span class="s2">&quot;Fluffy&quot;</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">Dog</span><span class="p">(</span><span class="s2">&quot;Rover&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">cats</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mydog</span><span class="p">))</span>
<span class="go">(&#39;Fluffy&#39;, &#39;Rover&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">cats</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mydog</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">),</span> <span class="n">frogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">))</span>
<span class="go">(&#39;Rover&#39;, &#39;Fluffy&#39;, &#39;Fluffy&#39;)</span>
</pre></div>
</div>
<p>It is possible to use <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> registrations in one module even
if another module registers the same type globally: within the module with the
module-local definition, all C++ instances will be cast to the associated bound
Python type.  In other modules any such values are converted to the global
Python type created elsewhere.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>STL bindings (as provided via the optional <code class="file docutils literal notranslate"><span class="pre">pybind11/stl_bind.h</span></code>
header) apply <code class="docutils literal notranslate"><span class="pre">py::module_local</span></code> by default when the bound type might
conflict with other modules; see <a class="reference internal" href="cast/stl.html#stl-bind"><span class="std std-ref">Binding STL containers</span></a> for details.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The localization of the bound types is actually tied to the shared object
or binary generated by the compiler/linker.  For typical modules created
with <code class="docutils literal notranslate"><span class="pre">PYBIND11_MODULE()</span></code>, this distinction is not significant.  It is
possible, however, when <a class="reference internal" href="embedding.html#embedding"><span class="std std-ref">Embedding the interpreter</span></a> to embed multiple modules in the
same binary (see <a class="reference internal" href="embedding.html#embedding-modules"><span class="std std-ref">Adding embedded modules</span></a>).  In such a case, the
localization will apply across all embedded modules within the same binary.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_local_bindings.cpp</span></code> contains additional examples
that demonstrate how <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> works.</p>
</div>
</div>
<div class="section" id="binding-protected-member-functions">
<h2>Binding protected member functions<a class="headerlink" href="#binding-protected-member-functions" title="永久链接至标题">¶</a></h2>
<p>It’s normally not possible to expose <code class="docutils literal notranslate"><span class="pre">protected</span></code> member functions to Python:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// error: &#39;foo&#39; is a protected member of &#39;A&#39;</span>
</pre></div>
</div>
<p>On one hand, this is good because non-<code class="docutils literal notranslate"><span class="pre">public</span></code> members aren’t meant to be
accessed from the outside. But we may want to make use of <code class="docutils literal notranslate"><span class="pre">protected</span></code>
functions in derived Python classes.</p>
<p>The following pattern makes this possible:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Publicist</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span> <span class="c1">// helper type for exposing protected functions</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// inherited with different access modifier</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="c1">// bind the primary class</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Publicist</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// expose protected methods via the publicist</span>
</pre></div>
</div>
<p>This works because <code class="docutils literal notranslate"><span class="pre">&amp;Publicist::foo</span></code> is exactly the same function as
<code class="docutils literal notranslate"><span class="pre">&amp;A::foo</span></code> (same signature and address), just with a different access
modifier. The only purpose of the <code class="docutils literal notranslate"><span class="pre">Publicist</span></code> helper class is to make
the function name <code class="docutils literal notranslate"><span class="pre">public</span></code>.</p>
<p>If the intent is to expose <code class="docutils literal notranslate"><span class="pre">protected</span></code> <code class="docutils literal notranslate"><span class="pre">virtual</span></code> functions which can be
overridden in Python, the publicist pattern can be combined with the previously
described trampoline:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Trampoline</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="n">PYBIND11_OVERLOAD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Publicist</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Trampoline</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="c1">// &lt;-- `Trampoline` here</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Publicist</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// &lt;-- `Publicist` here, not `Trampoline`!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>MSVC 2015 has a compiler bug (fixed in version 2017) which
requires a more explicit function binding in the form of
<code class="docutils literal notranslate"><span class="pre">.def(&quot;foo&quot;,</span> <span class="pre">static_cast&lt;int</span> <span class="pre">(A::*)()</span> <span class="pre">const&gt;(&amp;Publicist::foo));</span></code>
where <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(A::*)()</span> <span class="pre">const</span></code> is the type of <code class="docutils literal notranslate"><span class="pre">A::foo</span></code>.</p>
</div>
</div>
<div class="section" id="custom-automatic-downcasters">
<h2>Custom automatic downcasters<a class="headerlink" href="#custom-automatic-downcasters" title="永久链接至标题">¶</a></h2>
<p>As explained in <a class="reference internal" href="../classes.html#inheritance"><span class="std std-ref">Inheritance and automatic downcasting</span></a>, pybind11 comes with built-in
understanding of the dynamic type of polymorphic objects in C++; that
is, returning a Pet to Python produces a Python object that knows it’s
wrapping a Dog, if Pet has virtual methods and pybind11 knows about
Dog and this Pet is in fact a Dog. Sometimes, you might want to
provide this automatic downcasting behavior when creating bindings for
a class hierarchy that does not use standard C++ polymorphism, such as
LLVM <a class="footnote-reference brackets" href="#f4" id="id5">2</a>. As long as there’s some way to determine at runtime
whether a downcast is safe, you can proceed by specializing the
<code class="docutils literal notranslate"><span class="pre">pybind11::polymorphic_type_hook</span></code> template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">PetKind</span> <span class="p">{</span> <span class="n">Cat</span><span class="p">,</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">Zebra</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Pet</span> <span class="p">{</span>   <span class="c1">// Not polymorphic: has no virtual methods</span>
    <span class="k">const</span> <span class="n">PetKind</span> <span class="n">kind</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">protected</span><span class="o">:</span>
    <span class="n">Pet</span><span class="p">(</span><span class="n">PetKind</span> <span class="n">_kind</span><span class="p">)</span> <span class="o">:</span> <span class="n">kind</span><span class="p">(</span><span class="n">_kind</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="n">Pet</span> <span class="p">{</span>
    <span class="n">Dog</span><span class="p">()</span> <span class="o">:</span> <span class="n">Pet</span><span class="p">(</span><span class="n">PetKind</span><span class="o">::</span><span class="n">Dog</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sound</span> <span class="o">=</span> <span class="s">&quot;woof!&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bark</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sound</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">pybind11</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="nc">polymorphic_type_hook</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="n">Pet</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">*&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// note that src may be nullptr</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">==</span> <span class="n">PetKind</span><span class="o">::</span><span class="n">Dog</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">Dog</span><span class="p">);</span>
                <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Dog</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">src</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace pybind11</span>
</pre></div>
</div>
<p>When pybind11 wants to convert a C++ pointer of type <code class="docutils literal notranslate"><span class="pre">Base*</span></code> to a
Python object, it calls <code class="docutils literal notranslate"><span class="pre">polymorphic_type_hook&lt;Base&gt;::get()</span></code> to
determine if a downcast is possible. The <code class="docutils literal notranslate"><span class="pre">get()</span></code> function should use
whatever runtime information is available to determine if its <code class="docutils literal notranslate"><span class="pre">src</span></code>
parameter is in fact an instance of some class <code class="docutils literal notranslate"><span class="pre">Derived</span></code> that
inherits from <code class="docutils literal notranslate"><span class="pre">Base</span></code>. If it finds such a <code class="docutils literal notranslate"><span class="pre">Derived</span></code>, it sets <code class="docutils literal notranslate"><span class="pre">type</span>
<span class="pre">=</span> <span class="pre">&amp;typeid(Derived)</span></code> and returns a pointer to the <code class="docutils literal notranslate"><span class="pre">Derived</span></code> object
that contains <code class="docutils literal notranslate"><span class="pre">src</span></code>. Otherwise, it just returns <code class="docutils literal notranslate"><span class="pre">src</span></code>, leaving
<code class="docutils literal notranslate"><span class="pre">type</span></code> at its default value of nullptr. If you set <code class="docutils literal notranslate"><span class="pre">type</span></code> to a
type that pybind11 doesn’t know about, no downcasting will occur, and
the original <code class="docutils literal notranslate"><span class="pre">src</span></code> pointer will be used with its static type
<code class="docutils literal notranslate"><span class="pre">Base*</span></code>.</p>
<p>It is critical that the returned pointer and <code class="docutils literal notranslate"><span class="pre">type</span></code> argument of
<code class="docutils literal notranslate"><span class="pre">get()</span></code> agree with each other: if <code class="docutils literal notranslate"><span class="pre">type</span></code> is set to something
non-null, the returned pointer must point to the start of an object
whose type is <code class="docutils literal notranslate"><span class="pre">type</span></code>. If the hierarchy being exposed uses only
single inheritance, a simple <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">src;</span></code> will achieve this just
fine, but in the general case, you must cast <code class="docutils literal notranslate"><span class="pre">src</span></code> to the
appropriate derived-class pointer (e.g. using
<code class="docutils literal notranslate"><span class="pre">static_cast&lt;Derived&gt;(src)</span></code>) before allowing it to be returned as a
<code class="docutils literal notranslate"><span class="pre">void*</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="f4"><span class="brackets"><a class="fn-backref" href="#id5">2</a></span></dt>
<dd><p><a class="reference external" href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html">https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>pybind11’s standard support for downcasting objects whose types
have virtual methods is implemented using
<code class="docutils literal notranslate"><span class="pre">polymorphic_type_hook</span></code> too, using the standard C++ ability to
determine the most-derived type of a polymorphic object using
<code class="docutils literal notranslate"><span class="pre">typeid()</span></code> and to cast a base pointer to that most-derived type
(even if you don’t know what it is) using <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;void*&gt;</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_tagbased_polymorphic.cpp</span></code> contains a
more complete example, including a demonstration of how to provide
automatic downcasting for an entire class hierarchy without
writing one get() function for each class.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, Horizon Robotics

    </p>
  </div>
    
    
    
    利用 <a href="http://sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>