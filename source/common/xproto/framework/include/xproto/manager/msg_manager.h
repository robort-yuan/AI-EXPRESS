/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     msg_manager.h
 * \Author   Yingmin Li
 * \Mail     yingmin.li@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-04-22
 * \Brief    implement of msg_manager.h
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#ifndef XPROTO_INCLUDE_XPROTO_MANAGER_MSG_MANAGER_H_
#define XPROTO_INCLUDE_XPROTO_MANAGER_MSG_MANAGER_H_
#include <map>
#include <memory>
#include <mutex>
#include <vector>
#include <string>
#include <algorithm>
#include "xproto/message/pluginflow/flowmsg.h"
#include "xproto/plugin/xplugin.h"
#include "xproto/utils/singleton.h"
#include "xproto/threads/threadpool.h"
#include "xproto/message/pluginflow/msg_registry.h"
#include "hobotlog/hobotlog.hpp"

namespace horizon {
namespace vision {
namespace xproto {
class XMsgQueue : public hobot::CSingleton<XMsgQueue> {
 public:
  XMsgQueue() {
    msg_handle_.CreatThread(1);
    auto max_plugin_msg_str = getenv("max_plugin_msg");
    if (max_plugin_msg_str) {
      max_plugin_msg_ = atoi(max_plugin_msg_str);
    }
    auto msg_timeout_monitor_str = getenv("msg_timeout_monitor");
    if (msg_timeout_monitor_str) {
      msg_timeout_monitor_ = atoi(msg_timeout_monitor_str);
    }
  }
  ~XMsgQueue() = default;

 public:
  void RegisterPlugin(const XPluginPtr &plugin, const std::string& msg_type) {
    std::lock_guard<std::mutex> lck(mutex_);
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg_type);
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "try to register invalid msg type:" << msg_type
           << ", for plugin " << plugin->desc();
      return;
    }
    plugin->SetMsgMonitorTime(msg_timeout_monitor_);
    table_[type_handle].push_back(plugin);
  }
  void UnRegisterPlugin(const XPluginPtr &plugin, const std::string& msg_type) {
    std::lock_guard<std::mutex> lck(mutex_);
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg_type);
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE ||
        table_.find(type_handle) == table_.end()) {
      LOGW << "try to unregister invalid msg type:" << msg_type
           << ", for plugin " << plugin->desc();
      return;
    }
    auto iter = std::find(table_[type_handle].begin(),
                          table_[type_handle].end(), plugin);
    if (iter != table_[type_handle].end()) {
      LOGW << "to erase plugin: " << plugin->desc();
      table_[type_handle].erase(iter);
    }
  }

  void PushMsg(XProtoMessagePtr msg) {
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return;
    }
    std::unique_lock<std::mutex> lck(mutex_);  // support add and del plugins
    auto &plugins = table_[type_handle];
    while (true) {
      auto msg_queue_normal = true;
      for (auto &plugin : plugins) {
        auto msg_count = plugin->GetPluginMsgCount();
        auto plugin_msg_limit = plugin->GetPluginMsgLimit();
        auto max_plugin_msg_count =
            plugin_msg_limit <= 0 ? max_plugin_msg_ : plugin_msg_limit;
        if (msg_count >= max_plugin_msg_count) {
          msg_queue_normal = false;
          break;
        }
      }
      if (false == msg_queue_normal) {
        lck.unlock();
        LOGW << "PushMsg type: " << msg->type()
             << ", try to wait 500us until plugin msg-queue is free.";
        std::this_thread::sleep_for(std::chrono::microseconds(500));
        lck.lock();
      } else {
        lck.unlock();
        break;
      }
    }
    msg_handle_.PostTask(std::bind(&XMsgQueue::Dispatch, this, msg));
  }

  int TryPushMsg(XProtoMessagePtr msg) {
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return -1;
    }
    auto msg_queue_normal = true;
    {
      std::lock_guard<std::mutex> lck(mutex_);
      auto &plugins = table_[type_handle];
      for (auto &plugin : plugins) {
        auto msg_count = plugin->GetPluginMsgCount();
        auto plugin_msg_limit = plugin->GetPluginMsgLimit();
        auto max_plugin_msg_count =
            plugin_msg_limit <= 0 ? max_plugin_msg_ : plugin_msg_limit;
        if (msg_count >= max_plugin_msg_count) {
          msg_queue_normal = false;
          break;
        }
      }
    }
    if (false == msg_queue_normal) {
      return -1;
    }
    msg_handle_.PostTask(std::bind(&XMsgQueue::Dispatch, this, msg));
    return 0;
  }

 private:
  void Dispatch(XProtoMessagePtr msg) {
    std::lock_guard<std::mutex> lck(mutex_);
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return;
    }
    auto &plugins = table_[type_handle];
    for (auto &plugin : plugins) {
      plugin->OnMsg(msg);
    }
  }

 private:
  std::map<XPluginMsgTypeHandle, std::vector<XPluginPtr>> table_;
  hobot::CThreadPool msg_handle_;

  std::mutex mutex_;
  int max_plugin_msg_ = 30;
  int msg_timeout_monitor_ = 1000;  // ms
};

}  // namespace xproto
}  // namespace vision
}  // namespace horizon
#endif  // XPROTO_INCLUDE_XPROTO_MANAGER_MSG_MANAGER_H_
